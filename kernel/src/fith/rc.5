here
create version 1 cells allot
1 version !

: .( ')' parse type ; IMMEDIATE
.( Booting from internal rc.5...)

: \ 10 parse 2drop ; IMMEDIATE
\ Now we have backslash comments!
\
\ The ordering of early words in this boot file has the goal of supporting nested paren
\   comments as early as possible in the process, then defining only the words needed
\   to implement POSTPONE so we can use it for the rest of the control flow etc.
\
\ Words in this file are defined in lower case; that's because when running the RC,
\   all words automatically get the F_BUILTIN flag. This compares the downcased version
\   of a search word with the name in the dictionary, allowing upper or lower case to
\   match builtins. This only works if the words themselves are lower case.

: erase 0 fill ;	\ ( caddr u -- )

: '
 \ Can't use IF yet
 parse-word find-word dup 0= ?dup 2drop ;

\ We really only need this until we have postpone, but it makes defining early control
\ flow words easier. This only works because we're a traditional explicit return stack
\ forthlike.
: *compile r> dup @ , cell+ >r ;

: compile,	, ;
: [compile] ' compile, ; IMMEDIATE

: [']
  ' [compile] literal ; IMMEDIATE

\ Char handling
: char		parse-word drop c@ ;
: [char]	char [compile] literal ; IMMEDIATE

\ *** Control structures ***
\ condition IF truepart THEN rest
\ 		--> condition 0branch [offset] truepart rest
\ 		where offset is the offset of rest
\ condition IF truepart ELSE elsepart THEN rest
\ 		--> condition 0branch [offset0] truepart branch [offset1] elsepart rest
\ 		where offset0 is the offset of falsepart and offset1 is the offset of rest
: if
	*compile 0branch	\ Compile 0branch
	here				\ Remember where we are (on dstack)
	0 ,					\ Compile dummy offset
; IMMEDIATE

: then
	here over -	\ Offset is current HERE - remembered HERE
	swap !		\ Store the actual offset back at the dummy location
; IMMEDIATE

\ Note that the THEN word is identical between if and else - so else needs to
\ leave things in the state that IF does, ie. the addr of an offset to backpatch
\ on the dstack
: else
	*compile branch
	here		\ Remember where we are
	0 ,			\ Dummy elsepart offset
	swap		\ Backfill the original IF offset
	here over -
	swap !
; IMMEDIATE

  \ -- addr u
: s"
  '"' parse
  state @ if
	\ Compiling
	[compile] sliteral
  then
  \ In interpreting state, just let
; IMMEDIATE

\ 0= if <perror> then ...
: abort"
  *compile 0branch
  here
  0 ,
  [compile] s"
  *compile type
  *compile cr
  *compile abort
  here
  over -
  swap !
; IMMEDIATE

\ POSTPONE compiles a call to the following word, whether it is an immediate word or not.
: postpone
  parse-word 2dup find-word		\ ( -- addr u 0 | xt 1 | xt -1 )
  ?dup 0= if
	type ' ' emit true abort"  postpone?"
  then

  \ xt +- 1
  0> if
	\ Immediate word
	compile,
  else
	\ Non immediate
	[ ' literal compile, ]
	['] compile, compile,
  then
  2drop
; IMMEDIATE

\ ** Looping constructs
: begin
  here			\ Remember loop start
; IMMEDIATE

: until
  postpone 0branch
  here -
  ,
; IMMEDIATE

: while
  postpone 0branch
  here			\ Remember where we are, compile branch dummy
  0 ,
; IMMEDIATE

: repeat		\ ( bloc wloc -- )
  swap			\ ( wloc bloc )
  postpone branch
  here -		\ ( wloc offset )
  ,				\ ( wloc )
  here			\ ( wloc here )
  over -		\ ( wloc offset )
  swap !
; IMMEDIATE

\ NOT (boolean)
: not 0= ;

: unless
  postpone not
  [compile] if
; IMMEDIATE

\ Read the next chr from the input source
\ ( -- char flag ) Flag is true if char is valid, false if we hit the end of input.
: inch >in @ in@ in+ ;

\ Implement nestable paren comments. This scans the input forward using inch, keeping a count of
\ seen ( characters, and watching for the equivalent number of ).
: (
  1
  begin
	inch if				\ Get next chr is it valid?
	  dup '(' = if		\ If open paren, increment count
		drop
		1+
	  else				\ If close paren, decrement count
		')' = if
		  1-
		then
	  then
	else				\ If chr not valid, bail immediately by resetting count
	  drop 0
	then
  dup 0= until
  drop
; IMMEDIATE

( We now (have ((nested)) comments!) Yay!)

: h,	( half -- )	here 2 allot h! ;
: w,	( word -- )	here 4 allot w! ;

( addr u -- ) \ Compile the given string directly at HERE
: compile-str
  here				( addr u haddr )
  over allot align	( addr u haddr )
  swap cmove
;

: *emit-next 	 $next	 compile-str ;
: *emit-doesbody $dodoes compile-str ;
: *fix-cfa r> latest >cfa ! ;

\ does> creates a "defining word." A defining word, when executed, will create a new definition,
\ then emit a code sequence causing a jump from that word to the code sequence following the does>.
: does>
  postpone  *fix-cfa
  *emit-doesbody
; IMMEDIATE

: hide-name
  parse-word 2dup find-word		( addr u 0 | xt 1 | xt -1 )
  ?dup if						( addr u | xt )
	drop
	cfa>
	toggle-hide
	2drop
  else
	type
	' ' emit
	0 abort" unknown in hide-name"
  then
;

\ ** Variables, constants, values etc.

: 2! ( x1 x2 addr -- )	tuck !	cell+ ! ;
: 2@ ( addr -- x1 x2 )	dup cell+ @ swap @ ;

: variable	create 1 cells allot ;
: 2variable	create 2 cells allot ;
: wordlist	( -- wid )	here 1 cells allot ;

:  constant	variable  latest >cfa >body  ! does> @ ;
: 2constant	2variable latest >cfa >body 2! does> 2@ ;

: value constant ;
: to
  ' >body
  state @ if
	[compile] literal
	postpone !
  else
	!
  then
; IMMEDIATE

: to
  ' >body
  state @ if
	[compile] literal
	postpone +!
  else
	+!
  then
; IMMEDIATE

$20 constant	f_hidden
$40 constant	f_builtin
$80 constant	f_immediate
$1F constant	f_len_mask

\ **** DO, ?DO, LOOP, +LOOP
create		do-stack 8 cells allot
variable	do-sp	 0 do-sp !
  : do-addr	do-stack do-sp @ cells + ;

  : >do     do-addr ! 1 do-sp +! ;
  : do>		-1 do-sp +! do-addr @ ;

: do	( limit base -- )
		( c: -- do-token )
		( do-stack: -- leave-token )
	postpone 2>r	( we implement cstack with our return stack - separate c-stack might be faster? )
	0 >do here		( do-token )
; IMMEDIATE

: unloop	( r: inc limit index -- )
  r> 2r> 2drop >r
;

( Push the current leave token on the do stack
  onto the leave linked-list at here.
  Replace current leave token with here.
)
: push-leave
  here do>
  , >do
;

: ?do	( limit base -- )
	  	( c: -- do-token )
	  	( do-stack: -- leave-token )
  postpone 2dup
  [compile] do
  postpone <>
  postpone 0branch
  push-leave
  drop here
; IMMEDIATE

: leave
  postpone branch
  push-leave
; IMMEDIATE

\ fix up the given leave token and return the next
: fix-leave		( leave-token -- leave-token' )
  dup @ swap	( leave-token' leave-token )
  here over		( leave-token' leave-token here leave-token )
  - swap !		( leave-token! )
;

: loop-impl
  postpone 0branch
  here				( do-token here )
  -					( byte offset )
  ,

  \ Fix linked list of leave-tokens
  do> 		( leave-token )
  begin
	?dup while
	fix-leave
  repeat
  postpone 2r>
  postpone 2drop
;

: loop
  postpone looptest
  loop-impl
; IMMEDIATE

: +loop
  postpone +looptest
  loop-impl
; IMMEDIATE

\ ****Misc math and convenience

\ RECURSE makes a recursive call to the word that's currently being compiled.
\   Get the latest word created, move to its cfa, and compile that
: recurse
  latest >cfa compile, ; IMMEDIATE

: decimal 10 base ! ;
: hex     16 base ! ;

: d0= ( xd -- flag )	or 0= ;
: s>d ( n -- d )		dup 0< ;

: */mod  ( n1 n2 n3 -- rem quot )	>r m* r> sm/rem ;
: */     ( n1 n2 n3 -- quot )		*/mod nip ;

: signum	\ x -- -1/0/1
	dup 0< swap 0> - ;

: depth
  stack drop - 1 cells / ;

: count	\ caddr -- addr' ch
  dup 1+ swap c@ ;

: /string		\ ( addr u n -- addr' u' )
  tuck -
  >r + r>
;

: find			\ caddr -- caddr 0|xt 1|xt -1
  >r r@ count	\ ( addr u )
  find-word		\ ( 0 | xt 1 | xt -1 )
  dup 0= if
	r> swap		\ ( caddr 0 )
  else
	r> drop		\ ( xt 1|xt -1 )
  then
;

: word \ char "<chars>ccc<char>" -- caddr
  dup dup 1+ skip			\ Skip leading delimiter(s)
  dup 1+ swap parse-token	\ Grab word ( low hi -- addr u )
  >r here 1+ r@ cmove		\ Word will be copied to here+1 .. here+(len+1), 1st byte reserved for count
  r> here c!				\ Store count
  here
;

\ *** Printing

: char+		( addr -- addr' )	1+ ;
: chars		( m -- n )	;

\ PAD
256 constant pad-size
here pad-size allot value pad

\ PIC
300 aligned constant pic-size

here pic-size allot pic-size +
value pic-end

variable pic		0 pic !

\ Newline is ASCII 10
: '\n' 10 ;

\ ' ' is ascii 32
: bl	32 ;

\ SPACE prints a space
: space bl emit ;
: repchar	( char n -- )
  dup 0>	( char n flag )
  if
	0 do	( char )
		dup emit
	loop
  else
	drop
  then
  drop
;

: zeroes	( n -- )
  '0' swap repchar
;

: spaces	( n -- )
  bl swap repchar
;

: ."
  postpone s"
  state @ if
	postpone type
  else
	type
  then
; IMMEDIATE

\ *** Printing numbers
cr .( Printing... )

( num -- )
: u.
  base @ u/mod
  ?dup if
	recurse
  then

  dup 10 < if
	'0'
  else
	10 -
	'A'
  then
  +
  emit
;

\ Non destructively print the stack
: .s
  dsp@
  begin
	dup s0 @ <
  while
	dup @ u.
	space
	8+
  repeat
  cr
  drop
;

\ Return the width in characters of an unsigned number in the current base
\ ( u -- width )
: uwidth
  base @ u/
  ?dup if
	recurse 1+
  else
	1
  then
;

\ Print a number right justified in a field of width chars. xt is expected to print the padding.
: xu.r	( u width xt -- )
  >r
  swap		( width u )
  dup		( width u u )
  uwidth	( width u uwidth )
  rot		( u uwidth width )
  swap -	( u width-uwidth )
  ( At this point if we asked for a width narrower than the number, it'll be negative. )
  ( Spaces won't print a negative number of spaces anyway, so it's safe to call.)
  r> execute
  u.
;

: u.r			( u wid -- )
  ['] spaces	( u wid xt )
  xu.r ;

: u.0r
  ['] zeroes
  xu.r ;

\ Print a signed number, padded to a certain width.
: x.r		( n width xt -- )
  >r
  swap		( width n )
  dup 0< if
	negate		( width u )
	1			( flag to remember it was negative | width n 1 )
	swap
	rot
	1-			( 1 u width-1   -1 to account for the - sign in the output )
  else
	0			( width u 0 )
	swap		( width 0 u )
	rot			( 0 u width )
  then
  swap			( flag width u )
  dup uwidth	( flag width u uwidth )
  rot			( flag u uwidth width )
  swap -		( flag u width - uwidth )
  r> execute
  swap			( u flag )

  if '-' emit then	( print - if it was originally negative )
  u.
;

: .r
  ['] spaces
  x.r ;

: .0r
  ['] zeroes
  x.r ;

\ Finally we get to define .
: . 0 .r space ;

\ The real u. has a trailing space in the standard
: u. u. space ;

: ? ( addr -- ) @ . ;

: cells+ ( x n -- x+n cells )	cells + ;

\ Print the name of a word given its lfa
: id.	( addr -- )
  >name				( nfa )
  dup				( nfa nfa )
  c@ F_LEN_MASK and	( nfa len )
  dup 15 > >r
  15 min
  swap 1+ swap		( nfa+1 len )
  type
  r> if '+' emit then
  bl emit
;

: ?word-flag	( lfa wf -- flag )
  swap >name	( wf naddr )
  c@			( wf flagbyte )
  and 0<>		( true iff wf @ flagbyte )
;

: ?hidden	( lfa -- flag )
  F_HIDDEN ?word-flag
;

: ?builtin	( lfa -- flag )
  F_BUILTIN ?word-flag
;

: ?immediate	( lfa -- flag )
  F_IMMEDIATE ?word-flag
;

: words		( -- )
  latest
  begin
	?dup
  while
	dup ?hidden unless
	  dup id.
	then
	@
  repeat
  cr
;

: codepage create align
	\ The individual values will be backwards on the stack, ie. the 255th cp is first
	256 0 do
	  h,
	loop

	does>
	( cp addr -- unicode )
	swap $ff swap - 2* + h@
;

\ Only one we currently define is the IBM / DOS codepage (codepage 437, from wikipedia)
hex
0020 263A 263B 2665 2666 2663 2660 2022 25d8 25c8 25d9 2642 2640 266a 266b 263c  \ 0x / 0
25ba 25c4 2195 203c 00b6 00a7 25ac 21ab 2191 2193 2192 2190 221f 2194 25b2 25bc  \ 1x / 16
0020 '!'  '"'  '#'  '$'  '%'  '&'  '''  '('  ')'  '*'  '+'  ','  '-'  '.'  '/'   \ 2x / 32
'0'  '1'  '2'  '3'  '4'  '5'  '6'  '7'  '8'  '9'  ':'  ';'  '<'  '='  '>'  '?'   \ 3x / 48
'@'  'A'  'B'  'C'  'D'  'E'  'F'  'G'  'H'  'I'  'J'  'K'  'L'  'M'  'N'  'O'   \ 4x / 64
'P'  'Q'  'R'  'S'  'T'  'U'  'V'  'W'  'X'  'Y'  'Z'  '['  '\'  ']'  '^'  '_'   \ 5x / 80
'`'  'a'  'b'  'c'  'd'  'e'  'f'  'g'  'h'  'i'  'j'  'k'  'l'  'm'  'n'  'o'   \ 6x / 96
'p'  'q'  'r'  's'  't'  'u'  'v'  'w'  'x'  'y'  'z'  '{'  '|'  '}'  '~'  2302  \ 7x / 112
00c7 00fc 00e9 00e2 00e4 00e0 00e5 00e7 00ea 00eb 00e8 00ef 00ee 00ec 00c4 00c5  \ 8x / 128
00c9 00e6 00c6 00f4 00f6 00f2 00fb 00f9 00ff 00d6 00dc 00a2 00a3 00a5 20a7 0192  \ 9x / 144
00e1 00ed 00f3 00fa 00f1 00d1 00aa 00ba 00bf 2310 00ac 00bd 00bc 00a1 00ab 00bb  \ Ax / 160
2591 2592 2593 2502 2524 2561 2562 2556 2555 2563 2551 2557 255d 255c 255b 2510  \ Bx / 176
2514 2534 252c 251c 2500 253c 255e 255f 255a 2554 2569 2566 2560 2550 256c 2567  \ Cx / 192
2568 2564 2565 2559 2558 2552 2553 256b 256a 2518 250c 2588 2584 258c 2590 2580  \ Dx / 208
03b1 00df 0393 03c0 03a3 03c3 00b5 03c4 03a6 0398 03a9 03b4 221e 03c6 03b5 2229  \ Ex / 224
2261 00b1 2265 2264 2320 2321 00f7 2248 00b0 2219 00b7 221a 207f 00b2 25a0 00a0  \ Fx / 240
decimal
codepage cp437

variable current-codepage ' cp437 current-codepage !

: char-to-unicode		( char -- codepoint )
  current-codepage @ execute
;

variable basehold
: .2s base @ basehold ! 2 base ! .s basehold @ base ! ;

: utfbyte ( chr bits -- )
  dup
  1 swap lshift 1 -	( chr bits mask )
  rot and			( bits masked )
  %10				( bits masked 10 )
  rot lshift or
;

\ Encode 16 bit val to utf8 and emit the sequence
: uemit			( u -- )
  char-to-unicode
  2 base !
  dup $7f <= if
	emit
  else
	>r
	r@ $7ff <= if
		( two byte encoding )
		r@ 6 utfbyte		  ( chr byte2 )
		r@ 6 rshift 5 utfbyte ( byte2 pbyte1 )
		%10000000 or		  ( byte2 byte1 )
		emit emit
	else
	  r@ $FFFF <= if
		( three byte encoding )
		r@  6 utfbyte
		r@  6 rshift 6 utfbyte
		r@ 12 rshift 4 utfbyte
		%11000000 or
		emit emit emit
		else
			( four byte encoding )
			r@  6 utfbyte
			r@  6 rshift 6 utfbyte
			r@ 12 rshift 6 utfbyte
			r@ 18 rshift 3 utfbyte
			%11100000 or
			emit emit emit emit
		then
	 then
	 r> drop
  then
  10 base !
;

: urepchar ( ucp n -- )
  dup 0> if
	0 do
	  dup uemit
	loop
  else
	drop
  then
  drop
;

: dump-line		( addr n<=16 -- )
  base @ -rot	( base addr n -- )
  hex

  ?dup if
	over		( base addr n addr )
	16 u.r space			\ Print addr

	dup			( base addr n n )
	0 ?do		( base addr n )
	  over i +	( base addr n addr+i )
	  c@		( base addr n byte )
	  2 .0r space
	loop

	\ Print ascii equivalents
	dup			( base addr n n )
	3 *		    ( base addr n spc )

	\ Pad to char location


	[ 16 3 * ] literal	( base addr n spc bspc )
	swap -
	spaces			( base addr n )
	0 ?do
	  dup i +		( base addr addr+i )
	  c@			( base addr byte )
	  dup 1 >= if
		uemit
	  else
		drop '.' emit
	  then
	loop
  then
  drop
  base !
;

: dump 			( addr len -- )
  16 /mod				( addr len%16 len/16 -- )
  swap >r				( addr len/16 -- r: len%16 )

  dup
  0 ?do
	over i 16 * +		( len addr daddr )
	16 dump-line cr		( len addr )
  loop

  \ Dump a possible partial ending line
  16 *	+				( addr len )
  r> 					( len%16 addr-start )
  dump-line cr
;

: find-word-protected		( msg n -- )
  parse-word 2dup find-word	( msg n addr n 0|xt 1|xt -1 )
  ?dup 0= if
	." Word <"
	type
	." > not found: "
	type cr
	abort
  then		( msg n addr n xt )
  drop
  >r
  2drop
  2drop
  r>
;

: ascii
  base @
  decimal
  ."     0 1 2 3 4 5 6 7 8 9 A B C D E F" cr
  256 0 do
	i 16 mod 0= if
	  cr
	  hex
	  i 2 u.r
	  decimal
	  ." : "
	then
	i uemit space
  loop
  cr
  base !
;

: forget
  s" forget" find-word-protected
  cfa>
  dup	?builtin if
	drop
	abort" Can't forget builtin word."
  then
  dup @			( prev lfa )
  get-current !	( Update latest to prev word from forgotten )
  cp !			( Update here )
;

( Returns the depth of the dstack in words )
: depth
  s0 @ dsp@ -
  8 -			\ Because S0 was on the stack when we pushed DSP
  8/
;

\ **** CASE ... OF
cr .( case ... of...)

: case
  0			\ marker for bottom of stack
; IMMEDIATE

: of
	  postpone over
	  postpone =
	  [compile] if
	  postpone drop
; IMMEDIATE

: endof
  [compile] else
; IMMEDIATE

: endcase
  postpone drop
  begin
	?dup
  while
	[compile] then
  repeat
; IMMEDIATE

\ **** Exceptions
cr .( Exceptions...)

variable _handler 0 _handler !

: catch		( xt -- exn? )
  dsp@ >r
  _handler @ >r		\ Save dsp and prev handler
  rsp@ _handler !	\ Addr of return addr
  execute			\ Execute returns if no throw
  r> _handler !		\ Restore prev handler
  r> drop			\ Discard saved SP
  0					\ Flag "no throw"
;

: throw		( n -- )
  ?dup if
	_handler @
	?dup if
		rsp!	\ Restore prev return stack
		r> _handler !	\ Restore prev handler
		r> swap >r		\ Exc# on return stack
		dsp! drop r>	\ restore stack
		\ Return to the caller of CATCH because return stack is restored to the state
		\ when catch executed
	else
	  \ No handler, uncaught exception
	  dup -1 = if
		." Uncaught abort" cr
		abort		\ Call 1st abort implemented
	  else
		." Uncaught exception " . cr
	  then
	then
  then
;

\ Redefine abort in terms of throw; note that we also have to redefine abort"
\ since it references the old abort.
: abort
  -1 throw
;

\ 0= if <perror> then ...
: abort"
  postpone 0branch
  here
  0 ,
  [compile] s"
  postpone type
  postpone cr
  postpone abort
  here
  over -
  swap !
; IMMEDIATE

(
\ Test exceptions
: _foo-throw throw ;

: _test-exceptions
  25 ['] _foo-throw catch
  ?dup if
	cr ." Called _foo-throw and it threw exception number: " . cr
	drop	\ The argument of foo
  then
  0 ['] _foo-throw catch
  ?dup 0= if
	cr ." Called _foo-throw and it didn't throw, as exepcted." cr
  then

  1 _foo-throw
;

cr .( test-exceptions... )
_test-exceptions
)

\ **** Search Order / word / find / find-name / etc
cr .( Search order... )

: wordlist \ -- wid
  here 1 cells allot dup 0 swap !
;

: set-current ( wid -- )	current ! ;

get-current constant	forth-wordlist
wordlist    constant	environment

8 constant search-order-max
create search-context	search-order-max cells allot

variable #search-context	0 #search-context !

get-current constant forth-wordlist

: default-context	( -- forth-wordlist ... widn n )
  forth-wordlist
  1
;

: get-order	( -- widl ... widl n )
  #search-context @ 0 ?do
	#search-context @ i - 1- cells search-context + @
  loop
  #search-context @
;

: set-order ( widl ... widn n | -1 )
  dup -1 = if
	\ Push default wordlists
	drop
	default-context
  then

  dup #search-context !
  0 ?do i 1 - cells search-context + ! loop
;

\ Initialize to default-context
-1 set-order

\ Enough space to hold a max length counted string
create _word-buf 257 allot align

: word ( char -- c-addr )	\ Parse word delimited by char.
  _word-buf
  dup
  rot
  parse
  $toscs
;


(
environment set-current
: /counted-string		255 ;
: /hold					pic-size ;
: /pad					pad-size ;
: address-unit-bits		8
: core					true ;
: core-ext				false ;
: floored				false ;
: max-char				255 ;
: max-d					-1 -1 1 rshift ;
: max-n					$7fffffffffffffff ;
: max-u					-1 ;
: max-ud				-1 -1 ;
: return-stack-cells	rstack nip nip 1 cells / ;
: stack-cells			stack nip nip 1 cells / ;
: version				version @ ;
forth-wordlist	set-current



'd' emit

: environment?	( c-addr u -- false | i*x true )
  environment search-wordlist if
	execute
	true
  else
	false
  then
;
)

\ *** Interpret time if/then

\ *** code / code; and friends
: ;code
  postpone *fix-cfa
; IMMEDIATE

: (code) here latest >cfa ! ;
: code : (code) ;
: (end-code-int) latest toggle-hide [compile] [ ;
: (end-code) (end-code-int) ; IMMEDIATE
: end-code [compile] *emit-next (end-code-int) ; IMMEDIATE
hide-name (end-code-int)
hide-name (end-code)
hide-name (code)

'c' emit

.( Done.) cr

\ Print stats
here swap -
dup . .( / ) 8 / . .( bytes / cells used by startup code.) cr
