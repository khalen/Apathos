0 verbose-match !

here
get-ticks

: \ 10 parse 2drop ; IMMEDIATE
\ Now we have backslash comments!

\ Create some variables we need before we have variables
create version 1 cells allot
1 version !

create is-compiling-rc 1 cells allot
1 is-compiling-rc !

create run-tests 1 cells allot
0 run-tests !

: .( ')' parse type ; IMMEDIATE
.( Booting from internal rc.5...) cr

: ( ')' parse 2drop ; IMMEDIATE

\ The ordering of early words in this boot file has the goal of supporting nested paren
\   comments as early as possible in the process, then defining only the words needed
\   to implement POSTPONE so we can use it for the rest of the control flow etc.
\
\ Words in this file are defined in lower case; that's because when running the RC,
\   all words automatically get the F_BUILTIN flag. This compares the downcased version
\   of a search word with the name in the dictionary, allowing upper or lower case to
\   match builtins. This only works if the words themselves are lower case.

: erase 0 fill ;	\ ( caddr u -- )

: '
 \ Can't use IF yet
 parse-word find-word dup 0= ?dup 2drop ;

\ Newline is ASCII 10
: '\n' 10 ;

\ ' ' is ascii 32
: bl 32 ;

\ SPACE prints a space
: space bl emit ;

\ We really only need this until we have postpone, but it makes defining early control
\ flow words easier. This only works because we're a traditional explicit return stack
\ forthlike.
: *compile r> dup @ , cell+ >r ;

: compile,	, ;
: [compile] ' compile, ; IMMEDIATE

: [']
  ' [compile] literal ; IMMEDIATE

\ Char handling
: char		parse-word drop c@ ;
: [char]	char [compile] literal ; IMMEDIATE

\ *** Control structures ***
\ condition IF truepart THEN rest
\ 		--> condition 0branch [offset] truepart rest
\ 		where offset is the offset of rest
\ condition IF truepart ELSE elsepart THEN rest
\ 		--> condition 0branch [offset0] truepart branch [offset1] elsepart rest
\ 		where offset0 is the offset of falsepart and offset1 is the offset of rest

: forward,	( -- addr )		\ Compile a forward offset reference (push here, compile dummy offset)
	here 0 ,
;

: resolve-offset	( addr -- )		\ Resolve a previous forward offset
	here over - swap !
;

: if
	*compile 0branch	\ Compile 0branch
	forward,
; IMMEDIATE

: then
	resolve-offset
; IMMEDIATE

\ Note that the THEN word is identical between if and else - so else needs to
\ leave things in the state that IF does, ie. the addr of an offset to backpatch
\ on the dstack
: else
	*compile branch
	forward,
	swap						( offset-else ) \ Backfill the original IF offset
	resolve-offset
; IMMEDIATE

\ ** Looping constructs
: begin
  here			\ Remember loop start
; IMMEDIATE

: until
  *compile 0branch
  here -
  ,
; IMMEDIATE

: while
	*compile 0branch
	forward,
; IMMEDIATE

: repeat		\ ( bloc wloc -- )
  swap			\ ( wloc bloc )
  *compile branch
  here -		\ ( wloc offset )
	,				  \ ( wloc )
	resolve-offset
; IMMEDIATE

: again
	*compile branch
	here - ,
; IMMEDIATE

\ RECURSE makes a recursive call to the word that's currently being compiled.
\   Get the latest word created, move to its cfa, and compile that
: recurse
  latest >cfa compile, ; IMMEDIATE

  \ -- addr u
: s"
  '"' parse
  state @ if
	\ Compiling
	[compile] sliteral
  then
; IMMEDIATE

\ 0= if <perror> then ...
: abort"
  *compile 0branch
	[compile] if
	[compile] s"
  *compile type
  *compile cr
	*compile abort
	[compile] then
; IMMEDIATE

\ POSTPONE compiles a call to the following word, whether it is an immediate word or not.
: postpone
  parse-word 2dup find-word	\ ( -- addr u 0 | xt 1 | xt -1 )
  ?dup 0= if
	type ' ' emit true abort"  postpone?"
  then

  \ xt +- 1
  0> if
	\ Immediate word
	compile,
  else
	\ Non immediate
	[ ' literal compile, ]
	['] compile, compile,
  then
  2drop
; IMMEDIATE

\ NOT (boolean)
: not 0= ;

: unless
  postpone not
	postpone if
; IMMEDIATE

\ Read the next chr from the input source
\ ( -- char flag ) Flag is true if char is valid, false if we hit the end of input.
: inch >in @ in@ in+ ;

\ Implement nestable paren comments. This scans the input forward using inch, keeping a count of
\ seen ( characters, and watching for the equivalent number of ).
: (
  1
  begin
	inch if				\ Get next chr is it valid?
	  dup '(' = if		\ If open paren, increment count
		drop
		1+
	  else				\ If close paren, decrement count
		')' = if
		  1-
		then
	  then
	else				\ If chr not valid, bail immediately by resetting count
	  drop 0
	then
  dup 0= until
  drop
; IMMEDIATE

( We now (have ((nested)) comments!) Yay!)

: wrds	( n -- 2n )	\ Words are 2 bytes ie c shorts
  2*
;

: longs ( n -- 4n )	\ Longs are C 32 bit ints
  4*
;

: xlongs ( n -- 8n )	\ Xlongs are C 64 bit ints
  8*
;

: w,	( half -- )	here [ 1 wrds ] literal allot w! ;
: l,	( word -- )	here [ 1 longs ] literal allot l! ;

( addr u -- ) \ Compile the given string directly at HERE. NOTE: Flushes
\ dcache and icache assuming we are generating actual compiled code!
: compile-str
  here				( addr u haddr )
  over allot align	( addr u haddr )
	swap 2dup 2>r cmove
	2r> dcache-clean
	icache-flush
;

: *emit-next 	   $next	 compile-str ;
: *emit-doesbody $dodoes compile-str ;
: *fix-cfa r> latest >cfa ! ;

\ does> creates a "defining word." A defining word, when executed, will create a new definition,
\ then emit a code sequence causing a jump from that word to the code sequence following the does>.
: does>
  postpone  *fix-cfa
	*emit-doesbody
; IMMEDIATE

: hide-name
  parse-word 2dup find-word		( addr u 0 | xt 1 | xt -1 )
  ?dup if						( addr u | xt )
	drop
	cfa>
	toggle-hide
	2drop
  else
	type
	' ' emit
	0 abort" unknown in hide-name"
  then
;

\ ** Variables, constants, values etc.

: 2! ( x1 x2 addr -- )	tuck !	cell+ ! ;
: 2@ ( addr -- x1 x2 )	dup cell+ @ swap @ ;

: variable	create 1 cells allot ;
: 2variable	create 2 cells allot ;
: wordlist	( -- wid )	here 1 cells allot ;

:  constant	variable  latest >cfa >body  ! does> @ ;
: 2constant	2variable latest >cfa >body 2! does> 2@ ;

: buffer: ( amt -- addr )
	create allot align
;

: value constant ;
: to
  ' >body
  state @ if
	postpone literal
	postpone !
  else
	!
  then
; IMMEDIATE

: +to
  ' >body
  state @ if
	postpone literal
	postpone +!
  else
	+!
  then
; IMMEDIATE

$20 constant	f_hidden
$40 constant	f_builtin
$80 constant	f_immediate
$1F constant	f_len_mask

\ **** DO, ?DO, LOOP, +LOOP
create		do-stack 8 cells allot
variable	do-sp	 0 do-sp !
  : do-addr	do-stack do-sp @ cells + ;

  : >do     do-addr ! 1 do-sp +! ;
  : do>		-1 do-sp +! do-addr @ ;

: do	( limit base -- )
		( c: -- do-token )
		( do-stack: -- leave-token )
	postpone 2>r	( we implement cstack with our return stack - separate c-stack might be faster? )
	0 >do here		( do-token )
; IMMEDIATE

: unloop	( r: inc limit index -- )
  r> 2r> 2drop >r
;

( Push the current leave token on the do stack
  onto the leave linked-list at here.
  Replace current leave token with here.
)
: push-leave
  here do>
  , >do
;

: ?do	( limit base -- )
	  	( c: -- do-token )
	  	( do-stack: -- leave-token )
  postpone 2dup
  [compile] do
  postpone <>
  postpone 0branch
  push-leave
  drop here
; IMMEDIATE

: leave
  postpone branch
  push-leave
; IMMEDIATE

\ fix up the given leave token and return the next
: fix-leave		( leave-token -- leave-token' )
  dup @ swap	( leave-token' leave-token )
  here over		( leave-token' leave-token here leave-token )
  - swap !		( leave-token! )
;

: loop-impl
  postpone 0branch
  here				( do-token here )
  -					( byte offset )
  ,

  \ Fix linked list of leave-tokens
  do> 		( leave-token )
  begin
	?dup while
	fix-leave
  repeat
  postpone 2r>
  postpone 2drop
;

: loop
  postpone looptest
  loop-impl
; IMMEDIATE

: +loop
  postpone +looptest
  loop-impl
; IMMEDIATE

\ ****Misc math and convenience

: decimal 10 base ! ;
: hex     16 base ! ;

\ Return the width in characters of an unsigned number in the current base
\ ( u -- width )
: uwidth
  base @ u/
  ?dup if
	recurse 1+
  else
	1
  then
;

: d0= ( xd -- flag )	or 0= ;
: s>d ( n -- d )		dup 0< ;

: */mod  ( n1 n2 n3 -- rem quot )	>r m* r> sm/rem ;
: */     ( n1 n2 n3 -- quot )		*/mod nip ;

: signum	\ x -- -1/0/1
	dup 0< swap 0> - ;

: depth
  stack drop - 1 cells / ;

: count	\ caddr -- addr' ch
  dup 1+ swap c@ ;

: /string		\ ( addr u n -- addr' u' )
  tuck -
  >r + r>
;

\ *** Printing

: char+		( addr -- addr' )	1+ ;
: chars		( m -- n )	;

\ PAD
256 constant pad-size
here pad-size allot value pad

: ."
  postpone s"
  state @ if
	postpone type
  else
	type
  then
; IMMEDIATE



\ **** Exceptions
.( Exceptions...) cr

variable _handler 0 _handler !

: catch		( xt -- exn? )
  dsp@ >r
  _handler @ >r		\ Save dsp and prev handler
  rsp@ _handler !	\ Addr of return addr
  execute			\ Execute returns if no throw
  r> _handler !		\ Restore prev handler
  r> drop			\ Discard saved SP
  0					\ Flag "no throw"
;

: throw		( n -- )
  ?dup if
	_handler @
	?dup if
		rsp!	\ Restore prev return stack
		r> _handler !	\ Restore prev handler
		r> swap >r		\ Exc# on return stack
		dsp! drop r>	\ restore stack
		\ Return to the caller of CATCH because return stack is restored to the state
		\ when catch executed
	else
	  \ No handler, uncaught exception
	  dup -1 = if
		." Uncaught abort" cr
		abort		\ Call 1st abort implemented
	  else
		." Uncaught exception" cr
	  then
	then
  then
;

\ Redefine abort in terms of throw; note that we also have to redefine abort"
\ since it references the old abort.
: abort
  -1 throw
;

\ 0= if <perror> then ...
: abort"
  postpone 0branch
  here
  0 ,
  [compile] s"
  postpone type
  postpone cr
  postpone abort
  here
  over -
  swap !
; IMMEDIATE

\ ** Assertions
: averts
	parse-word 2dup find-word	\ ( -- addr u 0 | xt 1 | xt -1 )
	?dup 0= if
		type ' ' emit true abort"  averts?"
	then
	drop
	nip nip
	state @ if
		postpone 0=
		postpone 0branch
		here 0 ,
		swap postpone literal
	  postpone execute
		-20 postpone literal
		postpone throw
		here over - swap !
	else
		swap 0= if
			execute
			-20 throw
		else
			drop
		then
	then
; IMMEDIATE

: triggers		( flag "<name>" -- )
	parse-word 2dup find-word	\ ( -- addr u 0 | xt 1 | xt -1 )
	?dup 0= if
		type ' ' emit true abort"  triggers?"
	then
	drop
	nip nip
	state @ if
		postpone 0<>
		postpone 0branch
		here 0 ,
		swap postpone literal
		 postpone execute
		-20 postpone literal
		postpone throw
		here over - swap !
	else
		swap 0<> if
			execute
			-20 throw
		else
			drop
		then
	then
; IMMEDIATE

\ *** Printing numbers
.( Printing... ) cr

: cells+ ( x n -- x+n cells )	cells + ;

\ Print the name of a word given its lfa
: id.	( addr -- )
  >name				( nfa )
  dup				( nfa nfa )
  c@ F_LEN_MASK and	( nfa len )
  dup 15 > >r
  15 min
  swap 1+ swap		( nfa+1 len )
  type
  r> if '+' emit then
  bl emit
;

: ?word-flag	( lfa wf -- flag )
  swap >name	( wf naddr )
  c@			( wf flagbyte )
  and 0<>		( true iff wf @ flagbyte )
;

: ?hidden	( lfa -- flag )
  F_HIDDEN ?word-flag
;

: ?builtin	( lfa -- flag )
  F_BUILTIN ?word-flag
;

: ?immediate	( lfa -- flag )
  F_IMMEDIATE ?word-flag
;

: words		( -- )
  latest
  begin
	?dup
  while
	dup ?hidden unless
	  dup id.
	then
	@
  repeat
  cr
;

: codepage create align
	\ The individual values will be backwards on the stack, ie. the 255th cp is first
	256 0 do
	  w,
	loop

	does>
	( cp addr -- unicode )
	swap $ff swap - 2* + w@
;

\ Only one we currently define is the IBM / DOS codepage (codepage 437, from wikipedia)
hex
0020 263A 263B 2665 2666 2663 2660 2022 25d8 25c8 25d9 2642 2640 266a 266b 263c  \ 0x / 0
25ba 25c4 2195 203c 00b6 00a7 25ac 21ab 2191 2193 2192 2190 221f 2194 25b2 25bc  \ 1x / 16
0020 '!'  '"'  '#'  '$'  '%'  '&'  '''  '('  ')'  '*'  '+'  ','  '-'  '.'  '/'   \ 2x / 32
'0'  '1'  '2'  '3'  '4'  '5'  '6'  '7'  '8'  '9'  ':'  ';'  '<'  '='  '>'  '?'   \ 3x / 48
'@'  'A'  'B'  'C'  'D'  'E'  'F'  'G'  'H'  'I'  'J'  'K'  'L'  'M'  'N'  'O'   \ 4x / 64
'P'  'Q'  'R'  'S'  'T'  'U'  'V'  'W'  'X'  'Y'  'Z'  '['  '\'  ']'  '^'  '_'   \ 5x / 80
'`'  'a'  'b'  'c'  'd'  'e'  'f'  'g'  'h'  'i'  'j'  'k'  'l'  'm'  'n'  'o'   \ 6x / 96
'p'  'q'  'r'  's'  't'  'u'  'v'  'w'  'x'  'y'  'z'  '{'  '|'  '}'  '~'  2302  \ 7x / 112
00c7 00fc 00e9 00e2 00e4 00e0 00e5 00e7 00ea 00eb 00e8 00ef 00ee 00ec 00c4 00c5  \ 8x / 128
00c9 00e6 00c6 00f4 00f6 00f2 00fb 00f9 00ff 00d6 00dc 00a2 00a3 00a5 20a7 0192  \ 9x / 144
00e1 00ed 00f3 00fa 00f1 00d1 00aa 00ba 00bf 2310 00ac 00bd 00bc 00a1 00ab 00bb  \ Ax / 160
2591 2592 2593 2502 2524 2561 2562 2556 2555 2563 2551 2557 255d 255c 255b 2510  \ Bx / 176
2514 2534 252c 251c 2500 253c 255e 255f 255a 2554 2569 2566 2560 2550 256c 2567  \ Cx / 192
2568 2564 2565 2559 2558 2552 2553 256b 256a 2518 250c 2588 2584 258c 2590 2580  \ Dx / 208
03b1 00df 0393 03c0 03a3 03c3 00b5 03c4 03a6 0398 03a9 03b4 221e 03c6 03b5 2229  \ Ex / 224
2261 00b1 2265 2264 2320 2321 00f7 2248 00b0 2219 00b7 221a 207f 00b2 25a0 00a0  \ Fx / 240
decimal
codepage cp437

variable current-codepage ' cp437 current-codepage !

: char-to-unicode		( char -- codepoint )
  current-codepage @ execute
;

: utfbyte ( chr bits -- )
  dup
  1 swap lshift 1 -	( chr bits mask )
  rot and			( bits masked )
  %10				( bits masked 10 )
  rot lshift or
;

\ Encode 16 bit val to utf8 and emit the sequence
: uemit			( u -- )
  char-to-unicode
  2 base !
  dup $7f <= if
	emit
  else
	>r
	r@ $7ff <= if
		( two byte encoding )
		r@ 6 utfbyte		  ( chr byte2 )
		r@ 6 rshift 5 utfbyte ( byte2 pbyte1 )
		%10000000 or		  ( byte2 byte1 )
		emit emit
	else
	  r@ $FFFF <= if
		( three byte encoding )
		r@  6 utfbyte
		r@  6 rshift 6 utfbyte
		r@ 12 rshift 4 utfbyte
		%11000000 or
		emit emit emit
		else
			( four byte encoding )
			r@  6 utfbyte
			r@  6 rshift 6 utfbyte
			r@ 12 rshift 6 utfbyte
			r@ 18 rshift 3 utfbyte
			%11100000 or
			emit emit emit emit
		then
	 then
	 r> drop
  then
  10 base !
;

: urepchar ( ucp n -- )
  dup 0> if
	0 do
	  dup uemit
	loop
  else
	drop
  then
  drop
;

\ ** Pictured and numeric output

\ PIC
300 aligned constant pic-size

here pic-size allot pic-size +
value picend
variable pic		0 pic !
variable inpic		false inpic !

\ Double to double division - used by pictured output
: uml/mod
  dup >r
  0 swap um/mod
  r> swap >r
  um/mod
  r>
;

: ?in-pic	( -- ) \ Throw if not in pictured output
  inpic @ 0= if
	." Pictured output word used outside <# #>"
	-21 throw
  then
;

: hold			( ch -- )
  ?in-pic
  pic @			(  )
  1-
  tuck
  c!
  pic !
;

: <#	( -- )
  picend pic !
  1 inpic +!
;

: digit 	( n -- char )	\ Convert a num to a digit (incorrect for values > 36)
  9 over < if		\ 0 -> 48   10 -> 65
	7 +
  then
  '0' +
;

: ldigit 	( n -- char )	\ Convert a num to a digit (incorrect for values > 36)
  9 over > if		\ 0 -> 48   10 -> 97
	39 +
  then
  '0' +
;

: #			( ud -- ud' )
  ?in-pic
  base @
  uml/mod
  rot
  digit hold
;

: #s		( ud -- 0 )
  ?in-pic
  begin
	#
	2dup
	d0=
  until
;

: sign		( n -- )
  ?in-pic
  0< if
	'-' hold
  then
;

: #>
  ?in-pic
  2drop
  pic @
  picend
  over -
;

: #dsign		( n du -- ) \ Convert an unsigned double to a string, prepending a - sign if n < 0
  <#
  #s
  rot sign
  #>
;

: #str			( n -- caddr u )	\ Convert n to a string (signed)
  dup abs 0
  #dsign
;

: #ustr			( n -- caddr u )	\ Convert n to a string (signed)
  0 tuck
  #dsign
;

: #dstr			( n -- caddr u )	\ Convert n to a string (signed)
  tuck dabs
  #dsign
;

: #udstr			( n -- caddr u )	\ Convert n to a string (signed)
  0 -rot
  #dsign
;

: u.			( u -- )
  #ustr type space
;

: d.			( d -- )
  #dstr type space
;

: ud.			( d -- )
  #udstr type space
;

: repchar	( char n -- )
  dup 0>	( char n flag )
  if
	0 do	( char )
		dup emit
	loop
  else
	drop
  then
  drop
;

: zeroes	( n -- )
  '0' swap repchar
;

: spaces	( n -- )
  bl swap repchar
;

\ Print a number right justified in a field of width chars. xt is expected to print the padding.
: xud.r	( ud width xt -- )
  >r				( ud width )
  -rot #udstr		( width caddr u )
  rot over -
  r> execute
  type
;

: xd.r	( ud width xt -- )
  >r				( ud width )
  -rot #dstr		( width caddr u )
  rot over -
  r> execute
  type
;

\ Print a number right justified in a field of width chars. xt is expected to print the padding.
: xu.r	( u width xt -- )
  >r				( u width )
  swap #ustr		( width caddr u )
  rot over -		( caddr u n )
  r> execute
  type
;

: x.r	( ud width xt -- )
  >r			( ud width )
  swap #str		( width caddr u )
  rot over -	( caddr u n )
  r> execute
  type
;

: d.r			( u wid -- )
  ['] spaces	( u wid xt )
  xd.r ;

: d.0r
  ['] zeroes
  xd.r ;

: ud.r			( u wid -- )
  ['] spaces	( u wid xt )
  xud.r ;

: ud.0r
  ['] zeroes
  xud.r ;

: u.r			( u wid -- )
  ['] spaces	( u wid xt )
  xu.r ;

: u.0r
  ['] zeroes
  xu.r ;

: .r
  ['] spaces
  x.r ;

: .0r
  ['] zeroes
  x.r ;

: .
  base @ 10 = if
	#str
  else
	#ustr
  then
  type space
;

: x.
	base @
	hex
	swap .
	base swap !
;

\ Non destructively print the stack
: .s
  dsp@
  begin
	dup s0 @ <
  while
	dup @ u.
	space
	8+
  repeat
  cr
  drop
;

variable basehold
: .2s base @ basehold ! 2 base ! .s basehold @ base ! ;
: .xs base @ basehold ! hex .s basehold @ base ! ;

: ? ( addr -- ) @ . ;

: dump-xline		( addr n -- )
	base @ -rot	( base addr n -- )
	hex

	?dup if
	over		( base addr n addr )
	16 u.r space			\ Print addr

	dup			( base addr n n )
	8/
	0 ?do		( base addr n )
	  over i cells +	( base addr n addr+i )
	  @		( base addr n byte )
	  16 u.0r space
	loop

	\ Print ascii equivalents
	dup			( base addr n n )
	3 *		  ( base addr n spc )

	\ Pad to char location


	[ 16 3 * ] literal	( base addr n spc bspc )
	swap -
	spaces			( base addr n )
	0 ?do
	  dup i +		( base addr addr+i )
	  c@			( base addr byte )
	  dup 1 >= if
		uemit
	  else
		drop '.' emit
	  then
	loop
	then
	drop
	base !
;

: dump-line		( addr n<=16 -- )
  base @ -rot	( base addr n -- )
  hex

  ?dup if
	over		( base addr n addr )
	16 u.r space			\ Print addr

	dup			( base addr n n )
	0 ?do		( base addr n )
	  over i +	( base addr n addr+i )
	  c@		( base addr n byte )
	  2 u.0r space
	loop

	\ Print ascii equivalents
	dup			( base addr n n )
	3 *		    ( base addr n spc )

	\ Pad to char location


	[ 16 3 * ] literal	( base addr n spc bspc )
	swap -
	spaces			( base addr n )
	0 ?do
	  dup i +		( base addr addr+i )
	  c@			( base addr byte )
	  dup 1 >= if
		uemit
	  else
		drop '.' emit
	  then
	loop
  then
  drop
  base !
;

: dump 			( addr len -- )
  16 /mod				( addr len%16 len/16 -- )
  swap >r				( addr len/16 -- r: len%16 )

  dup
  0 ?do
	over i 16 * +		( len addr daddr )
	16 dump-line cr		( len addr )
  loop

  \ Dump a possible partial ending line
  16 *	+				( addr len )
  r> 					( len%16 addr-start )
  dump-line cr
;

: xdump 			  ( addr len -- )
	aligned
	16 /mod				( addr len%16 len/16 -- )
	swap >r				( addr len/16 -- r: len%16 )

	dup
	0 ?do
	over i 16 * +		( len addr daddr )
	16 dump-xline cr		( len addr )
	loop

	\ Dump a possible partial ending line
	16 *	+				( addr len )
	r> 					( len%16 addr-start )
	dump-xline cr
;

: find-word-protected		( msg n -- )
  parse-word 2dup find-word	( msg n addr n 0|xt 1|xt -1 )
  ?dup 0= if
	." Word <"
	type
	." > not found: "
	type cr
	abort
  then		( msg n addr n xt )
  drop
  >r
  2drop
  2drop
  r>
;

: ascii
  base @
  decimal
  ."     0 1 2 3 4 5 6 7 8 9 A B C D E F" cr
  256 0 do
	i 16 mod 0= if
	  cr
	  hex
	  i 2 u.r
	  decimal
	  ." : "
	then
	i uemit space
  loop
  cr
  base !
;

: forget
  s" forget" find-word-protected
  cfa>
  dup	?builtin if
	drop
	abort" Can't forget builtin word."
  then
  dup @			( prev lfa )
  get-current !	( Update latest to prev word from forgotten )
  cp !			( Update here )
;

( Returns the depth of the dstack in words )
: depth
  s0 @ dsp@ -
  8 -			\ Because S0 was on the stack when we pushed DSP
  8/
;

\ **** CASE ... OF
.( case ... of...) cr

: case
  0			\ marker for bottom of stack
; IMMEDIATE

: of
	  postpone over
	  postpone =
	  [compile] if
	  postpone drop
; IMMEDIATE

: endof
  [compile] else
; IMMEDIATE

: endcase
  postpone drop
  begin
	?dup
  while
	[compile] then
  repeat
; IMMEDIATE

\ Test exceptions
: _foo-throw throw ;

: _test-exceptions
  25 ['] _foo-throw catch
  ?dup if
	cr ." Called _foo-throw and it threw exception number: " . cr
	drop	\ The argument of foo
  then
  0 ['] _foo-throw catch
  ?dup 0= if
	cr ." Called _foo-throw and it didn't throw, as exepcted." cr
  then

  1 _foo-throw
;

: maybe-test-exceptions
	\ Don't have conditional compilation yet
	run-tests @ if
		.( test-exceptions... ) cr
		_test-exceptions
	then
;

' maybe-test-exceptions catch drop

\ **** Search Order / word / find / find-name / etc
.( Search order... ) cr

: wordlist \ -- wid
  here 1 cells allot dup 0 swap !
;

: set-current ( wid -- )	current ! ;

get-current constant	forth-wordlist
wordlist    constant	environment

16 constant max-orders
create search-context max-orders cells allot
variable #search-context	0 #search-context !

get-current constant forth-wordlist
wordlist    constant internal


: default-context	( -- forth-wordlist ... widn n )
	is-compiling-rc @ if
		forth-wordlist
		internal
		2
	else
		forth-wordlist
		1
	then
;

: get-order	( -- widl ... widl n )
  #search-context @ 0 ?do
	#search-context @ i - 1- cells search-context + @
  loop
  #search-context @
;

: set-order ( widl ... widn n | -1 )
  dup -1 = if
	\ Push default wordlists
	drop
	default-context
  then

  dup #search-context !
  0 ?do i cells search-context + ! loop
;

\ Initialize to default-context
-1 set-order

\ Given a nt, return the string name of the word represented
\ by that dict entry.
: name>string		( nt -- caddr u )
	c@ f_len_mask and
  swap 1+ swap
;

\ *** Search order compliant find-name / find

: word \ char "<chars>ccc<char>" -- caddr
  dup dup 1+ skip			\ Skip leading delimiter(s)
  dup 1+ swap parse-token	\ Grab word ( low hi -- addr u )
  >r here 1+ r@ cmove		\ Word will be copied to here+1 .. here+(len+1), 1st byte reserved for count
  r> here c!				\ Store count
  here
;

create _wordbuf_1	64	allot	_wordbuf_1 64 erase
create _wordbuf_2	64	allot	_wordbuf_2 64 erase

: setup-wordbufs	( addr u -- )	\ wb 1 has default case, wb 2 has downcased words
  2dup				( addr u addr u )
  _wordbuf_1 -rot	( addr u dst addr u )
  $toscs
  _wordbuf_2 -rot	( dst addr u )
  $toscs
  _wordbuf_2 stolower
;

: $find-name-in			( wid -- nt | 0 )	\ Assumes wordbuf 1 and 2 are set up
  >r
 _wordbuf_2 _wordbuf_1	( lowered normal )
  ['] matchxt			( lowered normal xt )
	r>						  ( lowered normal xt wid )
	exec-wordlist		( lowered normal 0 | xt 1 | xt -1 )
  ?dup if
	2swap 2drop
	swap xt>nt nip
  else
	2drop drop
	0
  then
;

: find-name-in			( caddr u wid )
  -rot setup-wordbufs
  $find-name-in
;

: find-name			( c-addr u -- nt 1 | nt -1 | 0 )
  setup-wordbufs	( -- )
  get-order			( widn ... widi n )
  0 swap			( widn ... widi 0 n )
  0 ?do				( widn...widi 0 )
	dup 0= if
	  drop $find-name-in
	else
	  nip
	then
  loop
;

: find-xt			( 0 | xt 1 | xt -1 )
  find-name		( nt | 0 )
  dup 0<> if
	dup name>	( nt lfa )
	?immediate if
	  1
	else
	  -1
	then
	swap name>compile swap
  then
;

\ Swap everything over to use the dictionary find-word
' find-xt find-word-vec !

: find			( caddr -- caddr 0 | xt )
  dup >r
  count find-name
  ?dup if
		state @ if
			name>compile
		else
			name>interpret
		then
  else
		r@ 0
  then
  r> drop
;

: discard	( x1 .. xn u -- ) \ Drop u+1 stack items
  0 ?do drop loop
;

: definitions	( -- )
  get-order swap set-current 1- discard
;

: also	( -- )
  get-order over swap 1+ set-order
;

: (wordlist) ( wid "<name>" -- ; )
  create ,
  does>
	@ >r
	get-order nip
	r> swap set-order
;

forth-wordlist (wordlist) forth

: only	( -- )	-1 set-order ;

: previous ( -- )
  get-order
  nip 1- set-order ;

\ Handy word for pushing a wid onto the search order
: >order
  >r get-order r> swap 1+ set-order
;

\ Enough space to hold a max length counted string
create _word-buf 257 allot align

: word ( char -- c-addr )	\ Parse word delimited by char.
  dup bl = if				\ If parsing blank separated, the standard suggests that 0 .. 32 should be sckipped but it isn't clear
		drop
		parse-word
  else
		dup dup 1+ skip
		dup 1+ swap parse-token
  then
  >r _word-buf 1+ r@ cmove
  r@ _word-buf c!
  _word-buf r> + bl c!	\ Trailing blank
  _word-buf
;

: internal-defs
	internal set-current
;

: public-defs
	forth-wordlist set-current
;

.( Environment...) cr

environment set-current
: /counted-string		255 ;
: /hold					pic-size ;
: /pad					pad-size ;
: address-unit-bits		8 ;
: core					true ;
: core-ext				false ;
: floored				false ;
: max-char				255 ;
: max-d					-1 -1 1 rshift ;
: max-n					$7fffffffffffffff ;
: max-u					-1 ;
: max-ud				-1 -1 ;
: return-stack-cells	rstack nip nip 1 cells / ;
: stack-cells			stack nip nip 1 cells / ;
: version				version @ ;
forth-wordlist	set-current

: environment?	( c-addr u -- false | i*x true )
  environment search-wordlist if
	execute
	true
  else
	false
  then
;

\ *** Interpret time if/then

.( [if] [else] [then]... ) cr

: [else]	( -- )
	1 begin									\ level
	begin bl word count dup while			\ level adr len
	  2dup s" [if]" cicompare 0= if
		2drop
		1+									\ level'
	  else									\ level adr len
		2dup s" [else]" cicompare 0= if
		  2drop
		  1-
		  dup if 1+ then					\ level'
		else
		  s" [then]" cicompare 0= if		\ level
			1-								\ level'
		  then
		then
	  then ?dup 0= if exit then				\ level'
	repeat 2drop
	refill 0= until
	drop
; IMMEDIATE

: [if]		( flag -- )
	0= if postpone [else] then
; IMMEDIATE

: [then]	( -- )
; IMMEDIATE

: [defined]
	bl word find nip 0<>
; IMMEDIATE

: [undefined]
	bl word find nip 0=
; IMMEDIATE

\ *** Simple string buffer
.( Strings... ) cr


256 buffer: strcat-buf

internal-defs
variable strcat-buf-pos
public-defs

: strcat-reset
	0 strcat-buf-pos !
;

strcat-reset

: strcat-add		( addr u -- )
	strcat-buf strcat-buf-pos @ + ( addr u dest )
	swap dup >r cmove
	r> strcat-buf-pos +!
;

: strcat-str
	strcat-buf strcat-buf-pos @
;

: constant-with-name		( val addr u -- )	\ Create a new constant at runtime w/the given name in the current dict
	\ There's no doubt a better way to do this. *create (build>) followed by direct compilation
	strcat-reset
	rot #ustr strcat-add
	s"  constant " strcat-add
	strcat-add
	strcat-str evaluate
;

\ Escaped string handling

internal-defs

1024 constant ss-buf-size

ss-buf-size buffer: ss-buf

: x-escaped-str-overflow	." Escaped string was too long, increase ss-buf-size" cr ;
: x-eoi-bksp							." End of input reading character following backspace" cr ;
: x-eoi-quote							." Unterminated s\" '"' emit ."  string" cr ;
: x-bad-hex								." Missing or malformed hex constant following \x" cr ;

: (append-ss-chr)	( c -- ) \ Append c to ss-buf and update its count
	ss-buf @ [ 1024 1 cells - ] literal < averts x-escaped-str-overflow
	ss-buf dup @	swap cell+ + c!
	1 ss-buf	+!
;

: (hex>) ( c -- u flag )	\ Convert a single 0-9|A-F|a-f chr to 0-15 value
	dup '0' >= over '9' <= and if
		'0' -
	else
		dup 'A' >= over 'Z' <= and if
			'A' - 10 +
		else
			dup 'a' >= over 'z' <= and if
				'a' - 10 +
			else
				x-bad-hex
				0 false
			then
		then
	then
;

: (2hex) ( -- u )		\ Parse 2 chars from the input stream and convert to a 1 byte hex digit
	inch averts x-bad-hex
	(hex>) 16 *
	inch averts x-bad-hex
	(hex>) +
;

: (handle-bksp) ( "c" -- )
	inch averts	x-eoi-bksp
	case
		'a' of	7		endof
		'b' of	8		endof
		'e' of	27	endof
		'f' of	12	endof
		'l' of	10	endof
		'm' of	10 (append-ss-chr) 13 endof			\ CR LF
		'n' of	10 (append-ss-chr) 13 endof			\ CR LF
		'q' of	34	endof
		'r' of	13	endof
		't' of	9		endof
		'v' of	11	endof
		'z' of	0		endof
		'"' of	34	endof
		'x' of	(2hex)	endof
		dup	\ Default, just append whatever was escaped. Note that this correctly handles "\\"
	endcase
	(append-ss-chr)
;

: (reset-ss-buf)	( -- )
	ss-buf ss-buf-size erase
;

public-defs

\ Process an escaped string. Compile time: caddr u via sliteral. Interpret time: caddr u
: s\"	( "ccc<quote>" -- caddr u )
	(reset-ss-buf)
	begin
		inch averts	x-eoi-quote
		dup '"' = if
			\ String finished
			drop
			ss-buf dup @			( addr len )
			swap cell+ swap		( addr' len )		\ Skip past length cell
			state @ if
				[compile] sliteral
			then
			\ Interpret time, leave caddr u on stack
			exit
		then

		dup '\' = if
			drop
			(handle-bksp)
		else
			(append-ss-chr)
		then
	again
; IMMEDIATE

run-tests @ [if]
internal-defs

: t-ct0
	." Should output -> Testing 1234 normal str<CR>" cr
	s\" Testing 1234 normal str" type cr
	." Should also output -> Testing 1234 normal str<CR>" cr
	s\" Testing 1234 normal str\n" type
	." Should output -> <TAB><BEL>This should be red<TAB>This should be bright<CR>" cr
	s\" \t\b\e[31mThis should be red\e[0m\t\e[1mThis should be bright\e[0m\n" type
;
t-ct0
.( Should output -> This is at interp time<CR>) cr
s\" This is at interp time\n" type
[then]

\ **** Structures
.( Structures...) cr

: begin-structure	( -- )
	create
	here 0 0 ,		\ Mark stack, lay dummy
	does> @
;

: +field		\ n "name" -- ; Exec: addr -- 'addr
  create over , +
  does> @ +
;

: field:
  aligned [ 1 cells ] literal +field
;

: wfield:
  1 #aligned [ 1 wrds ] literal +field
;

: lfield:
  2 #aligned [ 1 longs ] literal +field
;

: xfield:
  3 #aligned [ 1 cells ] literal +field
;

: end-structure		( addr n -- )
  swap !
;

\ **** Namespaced-field structures

internal-defs
.( Named structures...) cr
: +context:	( "name" wid -- )
  create immediate ,
  does>
  @ ( wid ) >order
;
public-defs

\ Make a new word list for the struct's field definitions expected to follow.
\ Pushes to the top of the search order + definitions so field defs go in this
\ wlist.
: struct:		( "name" -- wid 0 )	( order: -- wid )
  get-current	( wid ) 0
  wordlist
  dup +context:
  >order
  definitions ( wid 0 )
  s" : } previous ; immediate" evaluate
;

: '}'eval ( -- )
  s" }" evaluate
;

\ Terminate a structure definition begun with struct:'
\ 1) define "/struct", the structure size constant, in the struct namespace
\ 2) Restore the search order and compilation wlst to that just before the
\    invocation of "struct:"
: ;struct		( wid u -- )
  aligned
  s" constant /struct" evaluate
  ( wid ) set-current
  '}'eval
;

run-tests @ [if]		\ Tests
.( Namespaced struct tests...) cr
struct: person{
2 cells +field name
1 chars +field gender aligned
1 cells +field age
;struct

struct: girl{
person{
  /struct +field self
  /struct +field friend1
}
1 cells +field friend2
2 cells +field favdrink
;struct

create george person{ /struct } allot
create marie  girl{ /struct }   allot

: name1 s" Marie" ;
: name2 s" Bill" ;
: name3 s" George" ;
: drink1 s" cranberry juice" ;

name1	marie girl{ self person{ name } }		2!
'F'     marie girl{ self person{ gender } }		c!
23		marie girl{ self person{ age } }		!

name2	marie girl{ friend1 person{ name } }	2!
'M'     marie girl{ friend1 person{ gender } }	c!
25		marie girl{ friend1 person{ age } }		!

george	marie girl{ friend2 } !

name3	george	person{ name }		2!
'M'		george	person{ gender }	c!
21		george	person{ age }		!

drink1	marie	girl{ favdrink }	2!

: .gender ( char --)
  case
	'M' of	." male"	endof
	'F' of	." female"	endof
	." unspecified"
  endcase
;

: .. '.' emit ;


: show-girl	( instance -- )
cr ." Her name is "
	dup girl{ self person{ name } } 2@ type ..
cr ." Her gender is "
	dup girl{ self person{ gender } } c@ .gender ..
cr ." Her age is "
	dup girl{ self person{ age } } @ 2 .r ..
cr ." Her favorite drink is "
	dup girl{ favdrink } 2@ type ..
cr ." Friend #1's name is "
	dup girl{ friend1 person{ name } } 2@ type ..
cr ." Friend #1's gender is "
	dup girl{ friend1 person{ gender } } c@ .gender ..
cr ." Friend #1's age is "
	dup girl{ friend1 person{ age } } @ 2 .r ..
cr ." Friend #2's name is "
	dup girl{ friend2 } @ person{ name } 2@ type ..
cr ." Friend #2's gender is "
	dup girl{ friend2 } @ person{ gender } c@ .gender ..
cr ." Friend #2's age is "
		girl{ friend2 } @ person{ age } @ 2 .r .. bl emit
;

cr cr .( Here's Marie!)

marie show-girl
cr .( To see structure field names, execute:)
cr .(   "person{ words }" and "girl{ words }".)
cr

[then]

: see		( "<name>" -- )
	parse-word find-xt dup 0= abort" Word not found."
	swap

	dup
	cfa> ." : " id.
	cell+		\ Skip cf

	\ We have the XT of the word in question now
	begin
		dup @	['] exit <>
	while
		dup @
		case
		['] branch of ." branch( " cell+ dup @ 8/ . ." ) " endof
		['] 0branch of ." 0branch( " cell+ dup @ 8/ . ." ) " endof
		['] lit of cell+ dup @ . endof
		['] sbranch of ." s" '"' emit bl emit \ sliteral -> broff <str>
								cell+ dup @ +							\ Skip past str, next words are <lit> addr <lit> n
								cell+ dup @ >r
								cell+ cell+ dup @ r> swap type
								'"' emit bl emit
								endof
		dup cfa> id.
		endcase
		cell+
	repeat
	drop
	." ;"
	0> if ." IMMEDIATE"
	then
	cr
;

\ **** Lambdas
.( Lambdas... ) cr
: [:
	\ Compile the following structure:
	\ <branch>
	\ offset to lit xt push
	\ DOCOL		<- XT of Lambda
	\ ... Lambda code ...
	state @
	postpone branch
	forward,
	*docol ,
	]
; IMMEDIATE

: ;]
	\ Complete lambda definition:
	\ <branch target> LIT <addr of docol>
	\ ... Normal compilation continues

	\ On stack: addr of back ref jump offset
	postpone exit
	dup resolve-offset		( addr )  \ Back patch
	cell+								  ( addr' ) \ Skip to xt
	over if
	  [compile] literal
	else
		swap
	then
	state !
; IMMEDIATE

run-tests @ [if]
: twrd dup ?dup if id. false else true then ;

: test-lambda-word
	." Testing lambdas - should have output similar to 'words':" cr
	[:
	dup ?dup if id. false else true then
	;]	get-current exec-wordlist drop
	cr
;

test-lambda-word
.( testing outer lambda.. ) cr

[: ." Testing lambda outside colon def" cr ;] execute
[: ." Testing nested lambda (outside colon def):" [: ." Inner!" cr ;] execute ;] execute

.( Do does experiment) cr
: lambda-tbl		( cnt -- )
	create
	0 ?do , loop
	does> swap cells + @ execute ;

[: ." One" cr ;]
[: ." Two" cr ;]
[: ." Three" cr ;]
[: ." Four" cr ;]
[: ." Five" cr ;]
5 lambda-tbl testtbl

3 testtbl
0 testtbl
4 testtbl
2 testtbl
[then]

\ **** Modules
.( Modules...) cr

internal-defs

5 constant mod-stk-count
16 constant max-order

variable mod-stk-idx

begin-structure mod-ent-size
	field: module-count
	field: module-base
	field: module
	field: mod-old-current
end-structure

mod-ent-size mod-stk-count * buffer: module-stack

public-defs

: x-stk-overflow ." module stack overflow" cr ;
: x-stk-underflow ." module stack underflow" cr ;
: x-ord-overflow ." wordlist order overflow" cr ;
: x-defined ." module already defined" cr ;
: x-not-found ." module not found" cr ;
: x-tok-expected ." token expected" cr ;

internal-defs

: module-stack@
	mod-stk-idx @ 0<> if
		module-stack mod-stk-idx @ 1- mod-ent-size * +
	else
		0
	then
;

: push-stack	( wid -- )
	mod-stk-idx @ mod-stk-count < averts x-stk-overflow
	1 mod-stk-idx +!
	module-stack@
	0 over module-count !
	base @ over module-base !
	get-current over mod-old-current !
	over set-current
	module !
;

: drop-stack
	mod-stk-idx @ 1 > averts x-stk-underflow
	module-stack@
	dup mod-old-current @ set-current
	module-base @ base !
	get-order module-stack@ module-count @
	begin dup 0<> while
		1- swap 1- swap rot drop
	repeat
	drop
	set-order
	-1 mod-stk-idx +!
;

\ Add a wordlist to the search order
: add	( wid )
	>r get-order dup max-order < r> swap averts x-ord-overflow
	module-stack@ module-count @ 0<> if
		rot drop swap module-stack@ module @ swap 1+ set-order
	else
		swap 1+ set-order
	then
	mod-stk-idx @ 0<> averts x-stk-underflow
	module-stack@
	1 swap module-count +!
;

\ Remove a wordlist from the search order
: remove ( wid -- )
	mod-stk-idx @ 0 > averts x-stk-underflow
	>r get-order module-stack@ module-count @
	begin dup 0<> while
		dup 1+ pick r@ = if
			dup 1+ roll drop
			-1 module-stack@ module-count +!
			swap 1- swap
		then
		1-
	repeat
	drop rdrop set-order
;

\ Old find hook
variable old-find-hook

\ Find the first path separator in a name
: find-path-sep ( caddr u -- u'|-1 )
	swap 1+ swap 1-
	1
	begin
		over 2 >
	while
		2 pick c@ ':' = if
			2 pick 1+ c@ ':' = if
				nip nip exit
			then
		then
		rot 1+ rot 1- rot 1+
	repeat
	2drop drop -1
;

: ?drop			( ... 0 | <>0 -- ... | ... 0 )					\ Drop TOS but only if non zero
	dup 0<> if drop then
;

\ Execute or compile a word in the provided module
: do-module-find ( caddr u -- xt -1|xt 1|0 )
	2dup find-path-sep dup -1 <>  if										( caddr u u' )
		2 pick																						( caddr u u' caddr )
		over																							( caddr u u' caddr u' )
		old-find-hook @ execute														( caddr u u' 0|nt 1|nt -1 )
		?dup if drop																			( caddr u u' xt )
			>r 2 + tuck																			( caddr u'' u u' )
			- -rot +																				( u-u' caddr' )
			swap r>																					( caddr' u-u' xt )
			-rot 2>r																				( xt r: caddr' u-u' )
			>r get-order r>
			execute
			1 set-order
			2r> find-word
			dup if
				2>r set-order 2r>
			else
				drop set-order 0
			then
		else
			2drop drop 0
		then
	else
		drop old-find-hook @ execute
	then
;

public-defs

\ Start a module definition
: begin-module ( "name" -- )
	parse-word dup 0<> averts x-tok-expected
	2dup find-word
	?dup if
		['] x-defined execute -20 throw
	else
		wordlist dup >r -rot constant-with-name r>
	then
	dup push-stack
	add
;

: continue-module ( "name" -- )
	parse-word dup 0<> averts x-tok-expected
	2dup find-word
	?dup if
		drop nip nip execute
	else
		['] x-undefined execute -20 throw
	then
	dup push-stack
	add
;

\ Start a private module definition
: private-module		( -- )
	wordlist dup push-stack add
;

: end-module				( -- )
	drop-stack
;

\ End a module def and place the module on the stack
: end-module>
	mod-stk-idx @ 1 > averts x-stk-underflow
	module-stack@ module @
	drop-stack
;

\ Import a module
: import	add ;

\ Unimport a module
: unimport remove ;

0 mod-stk-idx !

.( Installing module word find hook...)
forth-wordlist push-stack
forth-wordlist add

find-word-vec @ old-find-hook !
' do-module-find find-word-vec !
.( Done.) cr

run-tests @ [if]
.( Module testing... Should be four Hellos and a Hello again) cr
begin-module modtest1
	10 constant tenconst
	20 constant twentyconst
	: printhi ." Hello modular world!" cr ;
	printhi
end-module

modtest1::printhi

modtest1 import
printhi
modtest1 unimport

continue-module modtest1
	: printhi1 printhi ." Hello again from modular world!" cr ;
end-module

modtest1::printhi1

[defined] printhi [if] .( printhi defined) cr [else] .( printhi undefined) cr [then]
[then]

: ?execute	( ... xt|0 -- ... ) \ Execute an xt if it isn't zero
	?dup if execute then
;

: defer ( "name" -- )	\ Define a name to hold
	create ['] abort ,
	does> ?execute
;

: defer@ ( deferrer -- xt ) >body @ ;
: defer! ( xt deferrer -- ) >body ! ;
: is	( "name" -- )
	state @ if
		postpone ['] postpone defer!
	else
		' defer!
	then
; IMMEDIATE

\ **** RPI SPECIFIC HARDWARE STUFF ****

\ Video
1280 constant framebuffer-width
720 constant framebuffer-hgt

1280 constant phys-width
720 constant phys-hgt

$FE000000 constant	peripheral-base

\ Firmware mailbox support
begin-module mailbox
	align32

	0 get-coherent-pg constant mbox-buffer

	: clear-mbox-buffer ( -- )
		mbox-buffer 40 longs erase
	;

	: get-mbox		( idx -- val )	\ Set the idx'th word in the mbox buffer to val
		longs mbox-buffer + l@
	;

	: set-mbox		( val idx -- )	\ Set the idx'th word in the mbox buffer to val
		longs mbox-buffer + l!
	;

	0 constant request

	begin-module ch
	  0 constant power
	  1 constant fb
	  2 constant vuart
	  3 constant vchiq
	  4 constant leds
	  5 constant btns
	  6 constant touch
	  7 constant count
	  8 constant prop
	end-module

	  peripheral-base $0000B880 +
		           constant mbox
	  mbox $00 + constant read
	  mbox $10 + constant poll
	  mbox $14 + constant sender
	  mbox $18 + constant status
	  mbox $1c + constant config
	  mbox $20 + constant write

	  $80000000 constant response
	  $80000000 constant full
	  $40000000 constant empty
		$00000000 constant last

		: wait-while-full  ( -- ) \ Wait until mbox isn't full
			begin
				status l@ full and
				0=
			until
		;

		: wait-while-empty ( -- ) \ Wait until mbox isn't empty
			begin
				status l@ empty and
				0=
		  until
		;

		: call ( byte -- )  \ Issue a video mb request, then wait until there is a reply
			data-sync-fence

			wait-while-full

			\ Write command
			$F and mbox-buffer +
			write l!

			begin
				wait-while-empty

				read l@ dup
				data-mem-fence
				$F and ch::prop =
			until
			$FFFFFFF0 and
		;

	begin-module	clocks

	  #1600000000	constant arm-clock-speed
	  #3800000000	constant dram-clock-speed

	  $00000000	constant reserved
		$00000001 constant emmc
		$00000002 constant uart
		$00000003 constant arm
		$00000004 constant core
		$00000005 constant v3d
		$00000006 constant h264
		$00000007 constant isp
		$00000008 constant sdram
		$00000009 constant pixel
		$0000000A constant pwm
		$0000000B constant hevc
		$0000000C constant emmc2
		$0000000D constant m2mc
		$0000000E constant pixel_bvb

		begin-module tag
		  $00030047	constant	get-clockrate-measured
		  $00038002	constant	set-clockrate
		  $00030004	constant	get-max-clockrate
		end-module

		: clock-call	( clkid tag -- value )
			mbox-buffer 40 longs 0 fill
			8 longs						0 set-mbox
			mailbox::request	1 set-mbox

			  ( tag )					2 set-mbox
			4 longs						3 set-mbox
			1 longs						4 set-mbox
			  ( clockid )     5 set-mbox
			0									6 set-mbox
			last							7 set-mbox

			ch::prop call if
				6 get-mbox
			else
				. ." : Clock call failed" cr
				abort" clock call failed"
			then
		;

		: get-max-clockrate	( clockid -- )
			tag::get-max-clockrate clock-call
		;

		: get-clockrate	( clockid -- )
			tag::get-clockrate-measured	clock-call
		;

		: set-clockrate	( clkid rate -- value )
			swap
			mbox-buffer 40 longs 0 fill
			8 longs						0 set-mbox
			mailbox::request	1 set-mbox

			tag::set-clockrate 2 set-mbox
			4 longs						3 set-mbox
			4 longs						4 set-mbox
			  ( clockid )     5 set-mbox
				( rate )				6 set-mbox
			last							7 set-mbox

			ch::prop call if
				6 get-mbox
			else
				. ." : Clock call failed" cr
				abort" clock call failed"
			then
		;

		arm   dup get-clockrate	swap get-max-clockrate	swap ." ArmClk  : " 10 u.r ."  cur, " 10 u.r ."  max" cr
		core  dup get-clockrate	swap get-max-clockrate	swap ." CoreClk : " 10 u.r ."  cur, " 10 u.r ."  max" cr
		emmc2 dup get-clockrate	swap get-max-clockrate	swap ." EMMC2Clk: " 10 u.r ."  cur, " 10 u.r ."  max" cr

	end-module


	\ Interface to video hardware mailbox
	begin-module videocore

		begin-module tag
			$28001 constant setpower
			$38002 constant setclkrate

			$48003 constant setphywh
			$48004 constant setvirtwh
			$48005 constant setdepth
			$48006 constant setpxlordr
			$48009 constant setvirtoff
			$40001 constant getfb
			$40008 constant getpitch
		end-module

		: init-framebuffer	( -- wid hgt pitch isrgb fbaddr )		\ Init the framebuffer and return its values

			35 longs  				 0 set-mbox		\ Length of msg in bytes
			mailbox::request   1 set-mbox

			tag::setphywh 		 2 set-mbox		\ Physical w/h
			2 longs						 3 set-mbox		\ Value size in bytes
			2 longs 					 4 set-mbox		\ Value size in bytes
			phys-width	 			 5 set-mbox
			phys-hgt		 			 6 set-mbox

			tag::setvirtwh 		 7 set-mbox		\ Virtual w/h
			2 longs						 8 set-mbox
			2 longs 					 9 set-mbox
			framebuffer-width	10 set-mbox
			framebuffer-hgt		11 set-mbox

			tag::setvirtoff		12 set-mbox
			2 longs						13 set-mbox
			2 longs						14 set-mbox
			0									15 set-mbox
			0									16 set-mbox		\ No offset

			tag::setdepth			17 set-mbox
			1 longs						18 set-mbox
			1 longs						19 set-mbox
			32								20 set-mbox		\ 32 bpp

			tag::setpxlordr		21 set-mbox
			1 longs						22 set-mbox
			1 longs						23 set-mbox
			1 								24 set-mbox		\ rgb

			tag::getfb				25 set-mbox
			2 longs						26 set-mbox
			2 longs						27 set-mbox
			4096							28 set-mbox		\ fbinfo.pointer
			0									29 set-mbox		\ fbinfo.size

			tag::getpitch			30 set-mbox
			1 longs						31 set-mbox
			1 longs						32 set-mbox
			0									33 set-mbox

			mailbox::last			34 set-mbox

			ch::prop	call	if
				20 get-mbox	32 =
				28 get-mbox 0<> and if
					10 get-mbox
					11 get-mbox
					33 get-mbox
					24 get-mbox
					29 get-mbox
					28 get-mbox $3FFFFFFF and
				else
					hex
					." BPP: " 20 get-mbox . cr
					." FB:  " 28 get-mbox . cr
					decimal
					abort" Couldn't init framebuffer."
				then
			then
		;

	end-module

end-module

.( Initializing framebuffer...) cr
mailbox::videocore::init-framebuffer

begin-module framebuffer
	constant addr
	constant size
	constant isrgb
	constant pitch
	constant height
	constant width

	: set-xel		( rgb x y -- )
		pitch * addr + longs + l!
	;

	: hline			( rgb	x	y len -- )	\ Draw a horizontal line starting at x, y .. len
		\ ." H: " .xs
		>r pitch * addr + swap longs +		( rgb xeladdr r: len )
		dup r> longs + swap					( rgb eaddr	saddr )
		?do	dup i l! 4 +loop
		drop
	;

	: vline			( rgb x y len -- )	\ Draw a vertical line starting at x, y .. len
		\ ." V: " .xs
		>r pitch * addr + swap longs +			\ saddr
		dup r> pitch * +				\ eaddr
		swap ?do dup i l! pitch +loop
		drop
	;

	0 value x
	0 value y
	0 value wid
	0 value hgt
	: box	( rgb x y wid hgt -- )
		\ ." Box: " .xs
		to hgt
		to wid
		to y
		to x
		dup x y       wid hline
		dup x y hgt + wid hline
		dup x y			  hgt vline
		    x wid + y hgt vline
	;

	: >rgb	( r g b -- 0rgb )
		     $FF and ( 0 lshift or )
		swap $FF and 8  lshift or	 ( r gb )
		swap $FF and 16 lshift or	 ( rgb  )
	;

	create dos-palette
	$55 $55 $55 >rgb l,
	$00 $00 $00 >rgb l,
	$55 $55 $FF >rgb l,
	$00 $00 $AA >rgb l,
	$55 $FF $55 >rgb l,
	$00 $AA $00 >rgb l,
	$55 $FF $FF >rgb l,
	$00 $AA $AA >rgb l,
	$FF $55 $55 >rgb l,
	$AA $00 $00 >rgb l,
	$FF $55 $FF >rgb l,
	$AA $00 $AA >rgb l,
	$FF $FF $55 >rgb l,
	$AA $55 $00 >rgb l,
	$FF $FF $FF >rgb l,
	$AA $AA $AA >rgb l,

	: dos-color	( i -- rgb )		\ Return the ith color in the dos palette
		longs dos-palette + l@
	;
end-module

hex
." framebuffer     : " framebuffer::addr . cr
." framebuffer-size: " framebuffer::size . cr
." isrgb           : " framebuffer::isrgb . cr
." pitch           : " framebuffer::pitch . cr
decimal
." width           : " framebuffer::width . cr
." height          : " framebuffer::height . cr

\ The goal of this is to get a minimal implementation of block read/write going on SD card, so we can have actual file I/O.
begin-module font

8 constant glyph-width
16 constant glyph-height

.( Loading font...) cr
create font-img-data
$0000000000000000 , $0000000000000000 , $BD8181A5817E0000 , $000000007E818199 ,
$C3FFFFDBFF7E0000 , $000000007EFFFFE7 , $7F7F7F3600000000 , $00000000081C3E7F ,
$7F3E1C0800000000 , $0000000000081C3E , $E7E73C3C18000000 , $000000003C1818E7 ,
$FFFF7E3C18000000 , $000000003C18187E , $3C18000000000000 , $000000000000183C ,
$C3E7FFFFFFFFFFFF , $FFFFFFFFFFFFE7C3 , $1111111111111F00 , $000000001F111111 ,
$BD99C3FFFFFFFFFF , $FFFFFFFFFFC399BD , $331E4C5870780000 , $000000001E333333 ,
$3C666666663C0000 , $0000000018187E18 , $0C0C0CFCCCFC0000 , $00000000070F0E0C ,
$C6C6C6FEC6FE0000 , $0000000367E7E6C6 , $E73CDB1818000000 , $000000001818DB3C ,
$1F7F1F0F07030100 , $000000000103070F , $7C7F7C7870604000 , $0000000040607078 ,
$1818187E3C180000 , $0000000000183C7E , $6666666666660000 , $0000000066660066 ,
$D8DEDBDBDBFE0000 , $00000000D8D8D8D8 , $6363361C06633E00 , $0000003E63301C36 ,
$0000000000000000 , $000000007F7F7F7F , $1111111111111F00 , $000000001F111111 ,
$1818187E3C180000 , $0000000018181818 , $1818181818180000 , $00000000183C7E18 ,
$7F30180000000000 , $0000000000001830 , $7F060C0000000000 , $0000000000000C06 ,
$0303000000000000 , $0000000000007F03 , $7F36140000000000 , $0000000000001436 ,
$3E1C1C0800000000 , $00000000007F7F3E , $3E3E7F7F00000000 , $0000000000081C1C ,
$0000000000000000 , $0000000000000000 , $18183C3C3C180000 , $0000000018180018 ,
$0000002466666600 , $0000000000000000 , $36367F3636000000 , $0000000036367F36 ,
$603E0343633E1818 , $000018183E636160 , $1830634300000000 , $000000006163060C ,
$3B6E1C36361C0000 , $000000006E333333 , $000000060C0C0C00 , $0000000000000000 ,
$0C0C0C0C18300000 , $0000000030180C0C , $30303030180C0000 , $000000000C183030 ,
$FF3C660000000000 , $000000000000663C , $7E18180000000000 , $0000000000001818 ,
$0000000000000000 , $0000000C18181800 , $7F00000000000000 , $0000000000000000 ,
$0000000000000000 , $0000000018180000 , $1830604000000000 , $000000000103060C ,
$6B6B6363361C0000 , $000000001C366363 , $1818181E1C180000 , $000000007E181818 ,
$0C183060633E0000 , $000000007F630306 , $603C6060633E0000 , $000000003E636060 ,
$7F33363C38300000 , $0000000078303030 , $603F0303037F0000 , $000000003E636060 ,
$633F0303061C0000 , $000000003E636363 , $18306060637F0000 , $000000000C0C0C0C ,
$633E6363633E0000 , $000000003E636363 , $607E6363633E0000 , $000000001E306060 ,
$0000181800000000 , $0000000000181800 , $0000181800000000 , $000000000C181800 ,
$060C183060000000 , $000000006030180C , $00007E0000000000 , $000000000000007E ,
$6030180C06000000 , $00000000060C1830 , $18183063633E0000 , $0000000018180018 ,
$7B7B63633E000000 , $000000003E033B7B , $7F6363361C080000 , $0000000063636363 ,
$663E6666663F0000 , $000000003F666666 , $03030343663C0000 , $000000003C664303 ,
$66666666361F0000 , $000000001F366666 , $161E1646667F0000 , $000000007F664606 ,
$161E1646667F0000 , $000000000F060606 , $7B030343663C0000 , $000000005C666363 ,
$637F636363630000 , $0000000063636363 , $18181818183C0000 , $000000003C181818 ,
$3030303030780000 , $000000001E333333 , $1E1E366666670000 , $0000000067666636 ,
$06060606060F0000 , $000000007F664606 , $636B7F7F77630000 , $0000000063636363 ,
$737B7F6F67630000 , $0000000063636363 , $63636363633E0000 , $000000003E636363 ,
$063E6666663F0000 , $000000000F060606 , $63636363633E0000 , $000070303E7B6B63 ,
$363E6666663F0000 , $0000000067666666 , $301C0663633E0000 , $000000003E636360 ,
$1818185A7E7E0000 , $000000003C181818 , $6363636363630000 , $000000003E636363 ,
$6363636363630000 , $00000000081C3663 , $6B6B636363630000 , $0000000036777F6B ,
$1C1C3E3663630000 , $000000006363363E , $183C666666660000 , $000000003C181818 ,
$0C183061637F0000 , $000000007F634306 , $0C0C0C0C0C3C0000 , $000000003C0C0C0C ,
$1C0E070301000000 , $0000000040607038 , $30303030303C0000 , $000000003C303030 ,
$0000000063361C08 , $0000000000000000 , $0000000000000000 , $0000FF0000000000 ,
$0000000000180C0C , $0000000000000000 , $3E301E0000000000 , $000000006E333333 ,
$66361E0606070000 , $000000003E666666 , $03633E0000000000 , $000000003E630303 ,
$33363C3030380000 , $000000006E333333 , $7F633E0000000000 , $000000003E630303 ,
$060F0626361C0000 , $000000000F060606 , $33336E0000000000 , $001E33303E333333 ,
$666E360606070000 , $0000000067666666 , $18181C0018180000 , $000000003C181818 ,
$6060700060600000 , $003C666660606060 , $1E36660606070000 , $000000006766361E ,
$18181818181C0000 , $000000003C181818 , $6B7F370000000000 , $00000000636B6B6B ,
$66663B0000000000 , $0000000066666666 , $63633E0000000000 , $000000003E636363 ,
$66663B0000000000 , $000F06063E666666 , $33336E0000000000 , $007830303E333333 ,
$666E3B0000000000 , $000000000F060606 , $06633E0000000000 , $000000003E63301C ,
$0C0C3F0C0C080000 , $00000000386C0C0C , $3333330000000000 , $000000006E333333 ,
$6666660000000000 , $00000000183C6666 , $6B63630000000000 , $00000000367F6B6B ,
$1C36630000000000 , $0000000063361C1C , $6363630000000000 , $001F30607E636363 ,
$18337F0000000000 , $000000007F63060C , $180E181818700000 , $0000000070181818 ,
$1800181818180000 , $0000000018181818 , $18701818180E0000 , $000000000E181818 ,
$000000003B6E0000 , $0000000000000000 , $63361C0800000000 , $00000000007F6363 ,
$03030343663C0000 , $00003E60303C6643 , $3333330000330000 , $000000006E333333 ,
$7F633E000C183000 , $000000003E630303 , $3E301E00361C0800 , $000000006E333333 ,
$3E301E0000330000 , $000000006E333333 , $3E301E00180C0600 , $000000006E333333 ,
$3E301E001C361C00 , $000000006E333333 , $0606663C00000000 , $0000003C60303C66 ,
$7F633E00361C0800 , $000000003E630303 , $7F633E0000630000 , $000000003E630303 ,
$7F633E00180C0600 , $000000003E630303 , $18181C0000660000 , $000000003C181818 ,
$18181C00663C1800 , $000000003C181818 , $18181C00180C0600 , $000000003C181818 ,
$6363361C08006300 , $000000006363637F , $6363361C001C361C , $000000006363637F ,
$3E06667F00060C18 , $000000007F660606 , $6C6E330000000000 , $00000000761B1B7E ,
$337F3333367C0000 , $0000000073333333 , $63633E00361C0800 , $000000003E636363 ,
$63633E0000630000 , $000000003E636363 , $63633E00180C0600 , $000000003E636363 ,
$33333300331E0C00 , $000000006E333333 , $33333300180C0600 , $000000006E333333 ,
$6363630000630000 , $001E30607E636363 , $636363633E006300 , $000000003E636363 ,
$6363636363006300 , $000000003E636363 , $060606663C181800 , $0000000018183C66 ,
$06060F0626361C00 , $000000003F670606 , $187E183C66660000 , $000000001818187E ,
$7B33231F33331F00 , $0000000063333333 , $187E181818D87000 , $00000E1B18181818 ,
$3E301E00060C1800 , $000000006E333333 , $18181C000C183000 , $000000003C181818 ,
$63633E00060C1800 , $000000003E636363 , $33333300060C1800 , $000000006E333333 ,
$66663B003B6E0000 , $0000000066666666 , $7B7F6F6763003B6E , $0000000063636373 ,
$007E007C36363C00 , $0000000000000000 , $003E001C36361C00 , $0000000000000000 ,
$060C0C000C0C0000 , $000000003E636303 , $037F000000000000 , $0000000000030303 ,
$607F000000000000 , $0000000000606060 , $0C18336343030300 , $00007C1830613B06 ,
$0C18336343030300 , $000060607C797366 , $1818180018180000 , $00000000183C3C3C ,
$1B366C0000000000 , $0000000000006C36 , $6C361B0000000000 , $0000000000001B36 ,
$2288228822882288 , $2288228822882288 , $55AA55AA55AA55AA , $55AA55AA55AA55AA ,
$EEBBEEBBEEBBEEBB , $EEBBEEBBEEBBEEBB , $1818181818181818 , $1818181818181818 ,
$1F18181818181818 , $1818181818181818 , $1F181F1818181818 , $1818181818181818 ,
$6F6C6C6C6C6C6C6C , $6C6C6C6C6C6C6C6C , $7F00000000000000 , $6C6C6C6C6C6C6C6C ,
$1F181F0000000000 , $1818181818181818 , $6F606F6C6C6C6C6C , $6C6C6C6C6C6C6C6C ,
$6C6C6C6C6C6C6C6C , $6C6C6C6C6C6C6C6C , $6F607F0000000000 , $6C6C6C6C6C6C6C6C ,
$7F606F6C6C6C6C6C , $0000000000000000 , $7F6C6C6C6C6C6C6C , $0000000000000000 ,
$1F181F1818181818 , $0000000000000000 , $1F00000000000000 , $1818181818181818 ,
$F818181818181818 , $0000000000000000 , $FF18181818181818 , $0000000000000000 ,
$FF00000000000000 , $1818181818181818 , $F818181818181818 , $1818181818181818 ,
$FF00000000000000 , $0000000000000000 , $FF18181818181818 , $1818181818181818 ,
$F818F81818181818 , $1818181818181818 , $EC6C6C6C6C6C6C6C , $6C6C6C6C6C6C6C6C ,
$FC0CEC6C6C6C6C6C , $0000000000000000 , $EC0CFC0000000000 , $6C6C6C6C6C6C6C6C ,
$FF00EF6C6C6C6C6C , $0000000000000000 , $EF00FF0000000000 , $6C6C6C6C6C6C6C6C ,
$EC0CEC6C6C6C6C6C , $6C6C6C6C6C6C6C6C , $FF00FF0000000000 , $0000000000000000 ,
$EF00EF6C6C6C6C6C , $6C6C6C6C6C6C6C6C , $FF00FF1818181818 , $0000000000000000 ,
$FF6C6C6C6C6C6C6C , $0000000000000000 , $FF00FF0000000000 , $1818181818181818 ,
$FF00000000000000 , $6C6C6C6C6C6C6C6C , $FC6C6C6C6C6C6C6C , $0000000000000000 ,
$F818F81818181818 , $0000000000000000 , $F818F80000000000 , $1818181818181818 ,
$FC00000000000000 , $6C6C6C6C6C6C6C6C , $FF6C6C6C6C6C6C6C , $6C6C6C6C6C6C6C6C ,
$FF18FF1818181818 , $1818181818181818 , $1F18181818181818 , $0000000000000000 ,
$F800000000000000 , $1818181818181818 , $FFFFFFFFFFFFFFFF , $FFFFFFFFFFFFFFFF ,
$FF00000000000000 , $FFFFFFFFFFFFFFFF , $0F0F0F0F0F0F0F0F , $0F0F0F0F0F0F0F0F ,
$F0F0F0F0F0F0F0F0 , $F0F0F0F0F0F0F0F0 , $00FFFFFFFFFFFFFF , $0000000000000000 ,
$1B3B6E0000000000 , $000000006E3B1B1B , $331B3333331E0000 , $0000000033636363 ,
$03030363637F0000 , $0000000003030303 , $3636367F00000000 , $0000000036363636 ,
$180C06637F000000 , $000000007F63060C , $1B1B7E0000000000 , $000000000E1B1B1B ,
$6666666600000000 , $0000000306063E66 , $18183B6E00000000 , $0000000018181818 ,
$66663C187E000000 , $000000007E183C66 , $7F6363361C000000 , $000000001C366363 ,
$36636363361C0000 , $0000000077363636 , $667C30180C780000 , $000000003C666666 ,
$DBDB7E0000000000 , $0000000000007EDB , $DBDB7E60C0000000 , $0000000003067ECF ,
$063E06060C380000 , $00000000380C0606 , $636363633E000000 , $0000000063636363 ,
$7F00007F00000000 , $00000000007F0000 , $187E181800000000 , $00000000FF000018 ,
$306030180C000000 , $000000007E000C18 , $0C060C1830000000 , $000000007E003018 ,
$181818D8D8700000 , $1818181818181818 , $1818181818181818 , $000000000E1B1B1B ,
$7E00181800000000 , $0000000000181800 , $003B6E0000000000 , $0000000000003B6E ,
$0000001C36361C00 , $0000000000000000 , $1800000000000000 , $0000000000000018 ,
$0000000000000000 , $0000000000000018 , $373030303030F000 , $00000000383C3636 ,
$0036363636361B00 , $0000000000000000 , $001F13060C1B0E00 , $0000000000000000 ,
$3E3E3E3E00000000 , $00000000003E3E3E , $0000000000000000 , $0000000000000000 ,

		: get-glyph-bits ( u -- a b )	\ Gets the 2 cells of img data for glyph u
			2 * cells font-img-data + 2@
		;

		: draw-glyph	( fgrgb bgrgb glyph x y -- )
			rot get-glyph-bits 2>r					( frgb brgb x y  r: gh gl )
			framebuffer::pitch *						( frgb brgb x yoff )
			swap longs											( frgb brgb yoff xoff )
			framebuffer::addr + +	\ Calc fb start address

			\ Top glyph word
			( frgb brgb addr )
			r> framebuffer::pitch ( frgb brgb addr  x0 pitch ) (draw-hgi)
			r> framebuffer::pitch ( frgb brgb addr' x1 pitch ) (draw-hgi)
			2drop drop
		;

		: draw-chart	( -- )
			256 0 do
				i 16 /mod					( col row )
			  glyph-height * swap					( row*16 col )
				glyph-width * swap					( x y )
				i 15 mod 1 +
				dup framebuffer::dos-color						( x y idx fgc )
				swap 16 swap - framebuffer::dos-color ( x y fgc bgc )
				2swap				( fgc bgc x y )
				i						( fgc bgc x y glyph )
				draw-glyph
			loop
		;

end-module

begin-module screen

	font import

	framebuffer::width font::glyph-width / constant screen-width
	framebuffer::height font::glyph-height / constant screen-height

	.( The screen is ) screen-width u. .(  x ) screen-height u. .( Characters) cr

	screen-width screen-height *       buffer: screen-buf
	screen-width screen-height * longs buffer: fgcol-buf
	screen-width screen-height * longs buffer: bgcol-buf

	256 longs buffer: palette
	palette 256 longs 0 fill
	: set-palette	( col slot -- )
		longs palette + !
	;

	: init-palette
		16 0 do
			i framebuffer::dos-color i set-palette
		loop
	;

	0 value x0	0 value y0
	0 value x1  0 value y1
	0 value chr
	0 value fg	0 value bg

	: scr-coord-addr ( x y -- addr )
		screen-width * + screen-buf +
	;

	: colbuf-addr ( addr x y -- addr' )
		screen-width * + longs +
	;

	: fgcol-addr ( x y -- addr )
		fgcol-buf -rot colbuf-addr
	;

	: bgcol-addr ( x y -- addr )
		bgcol-buf -rot colbuf-addr
	;

	: scr@		( x y -- chr )
		scr-coord-addr c@
	;
	: scr!		( chr x y -- )
		scr-coord-addr c!
	;

	: fgcol@	( x y -- col )
		fgcol-addr l@
	;
	: fgcol!	( rgbcol x y -- )
		fgcol-addr l!
	;

	: bgcol@	( x y -- col )
		bgcol-addr l@
	;

	: bgcol!	( bgcol x y -- )
		bgcol-addr l!
	;

	: (do-scr-rect)		( xt -- )	\ Run xt for each cell in the rect stored in x0, y0, x1, y1
		y1 y0 ?do
			x1 x0 ?do
				dup								( xt xt )
				i j rot execute		( xt xt soff )
			loop
		loop
		drop
	;

	variable cur-fg-col
	variable cur-bg-col

	: scr-fill-rect	( chr x y wid hgt -- )
		rot		( .. wid hgt y )
		swap  over + ( ... x wid y0 y1 )
		to y1
		to y0

		over + to x1
		to x0

		to chr

		[: chr -rot scr!  ;] (do-scr-rect)
		[: cur-bg-col @ -rot bgcol! ;] (do-scr-rect)
		[: cur-fg-col @ -rot fgcol! ;] (do-scr-rect)
	;

	: scr>xels ( x y -- x' y' )
		font::glyph-height * swap font::glyph-width * swap
	;

	: paint-chr ( x y -- )
		2>r
		2r@ fgcol@
		2r@ bgcol@
		2r@ scr@
		2r>

		scr>xels
		font::draw-glyph
	;

	: paint-screen	( -- )
		screen-height 0 do
			screen-width 0 do
				i j paint-chr
			loop
		loop
	;

	: set-chr-colors	( fgcol bgcol chr x y -- )
		2dup 2>r
		scr!
		2r@ bgcol!
		2r> fgcol!
	;

	: set-fg	( fgcol -- )
		cur-fg-col !
	;

	: set-bg	( bgcol -- )
		cur-bg-col !
	;

	: set-fg-bg		( fgcol bgcol -- )
		set-bg
		set-fg
	;

	: set-chr ( chr x y -- )
		2>r >r
		cur-fg-col @ cur-bg-col @
		r> 2r>
		set-chr-colors
	;

	: clear	( -- )
		bl
		0 0 screen-width screen-height
		scr-fill-rect
	;

	variable cur-x		0 cur-x !
	variable cur-y		0 cur-y !

	: home ( -- )
		0 dup cur-x ! cur-y !
	;

	: goto ( x y -- )
		cur-y ! cur-x !
	;

	\ Clear to the end of the current line.
	: clear-eol ( -- )
		cur-y @
		cur-x screen-width ?do
			bl over i swap set-chr
		loop
	;

	: clear-eos ( -- )
		bl
		cur-x @ dup screen-width swap - ( bl x wid )
		cur-y @ dup screen-height swap - ( bl x wid y hgt )
		rot swap		( bl x y wid hgt )
		scr-fill-rect
	;

	: print ( addr u -- )		\ Write text to the screen at cur x & y, updating
		screen-width cur-x @ - min	\ Clip len if would pass the right of the screen
		dup 0 ?do								( addr u )
			over i + c@					( addr u c )
			cur-x @ i + cur-y @ ( addr c x y )
			set-chr
		loop
		cur-x +! drop
	;

	: print-at ( x y addr u -- )
		2swap cur-y ! cur-x !
		print
	;

end-module

begin-module random
	variable randstate		0 randstate !

	#2862933555777941757 constant multiplier
	#3037000493					 constant addend

	: seed ( v -- )
		randstate !
	;

	\ Return a 56 bit random number
	: next ( -- rval )
		randstate @
		multiplier *
		addend +
		dup randstate !
		8 rshift
	;

	: range	( min max -- )
		over -
		next swap mod +
	;

end-module

begin-module syscall

: syscalln	( a0 .. an n call -- u )
		*syscall
;

: syscall0 ( call -- u )
		0 swap syscalln
;

: syscall1 ( call -- u )
		1 swap syscalln
;

: syscall2 ( call -- u )
		2 swap syscalln
;

: syscall3 ( call -- u )
		3 swap syscalln
;

: syscall4 ( call -- u )
		4 swap syscalln
;

: syscall5 ( call -- u )
		5 swap syscalln
;

: syscall6 ( call -- u )
		6 swap syscalln
;

: syscall-test ( -- )
		." Testing syscalls 10-16 w/varying args..." cr
		17 10 do
			i 10 - 0 ?do
				i j + 20 *
			loop
			i 10 -
			i
			syscalln
			."   SC " i . ." returned " . cr
		loop
;

.( Syscall tests: ) cr
syscall-test

end-module

: do-for-millis ( ms xt -- )
	swap 1000 * get-ticks + >r		( xt  r: ms )
	0
	begin
		r@ get-ticks >
	while
		1+
		over execute
	repeat
	r> drop
;

: .time
	parse-word 2dup
	find-word ( addr u 0|xt -1|xt 1 ) 0= if type ."  .time?" cr -21 throw then
	get-ticks >r ?execute get-ticks r> -
	-rot type ."  executed in " . ."  ticks." cr
;

1 [if]
random import

.time font::draw-chart
.time screen::clear
.time screen::paint-screen

: randprint
	0 screen::screen-width range
	0 screen::screen-height range
	next next screen::set-fg-bg
	s" Hello!"
	screen::print-at
	screen::paint-screen
;

: testrandprint
	2000 ['] randprint do-for-millis
	." Able to do " . ."  iterations of print+update in 2 seconds." cr
;

testrandprint
drop

random unimport
[then]

\ Print stats
get-ticks swap -
1000 /
swap here swap -
dup . .( / ) 8 / . .( bytes / cells used by startup code.) cr
.( Loaded in ) . .( ms.) cr
\ Hide internal words (is-compiling-rc 0 = remove internal from default search order)
0 is-compiling-rc !
-1 set-order
