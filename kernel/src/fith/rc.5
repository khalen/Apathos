here
get-ticks

: \ 10 parse 2drop ; IMMEDIATE
\ Now we have backslash comments!

\ Create some variables we need before we have variables
create version 1 cells allot
1 version !

create is-compiling-rc 1 cells allot
1 is-compiling-rc !

create run-tests 1 cells allot
0 run-tests !

: .( ')' parse type ; IMMEDIATE
.( Booting from internal rc.5...)

: ( ')' parse 2drop ; IMMEDIATE

\ The ordering of early words in this boot file has the goal of supporting nested paren
\   comments as early as possible in the process, then defining only the words needed
\   to implement POSTPONE so we can use it for the rest of the control flow etc.
\
\ Words in this file are defined in lower case; that's because when running the RC,
\   all words automatically get the F_BUILTIN flag. This compares the downcased version
\   of a search word with the name in the dictionary, allowing upper or lower case to
\   match builtins. This only works if the words themselves are lower case.

: erase 0 fill ;	\ ( caddr u -- )

: '
 \ Can't use IF yet
 parse-word find-word dup 0= ?dup 2drop ;

\ Newline is ASCII 10
: '\n' 10 ;

\ ' ' is ascii 32
: bl 32 ;

\ SPACE prints a space
: space bl emit ;

\ We really only need this until we have postpone, but it makes defining early control
\ flow words easier. This only works because we're a traditional explicit return stack
\ forthlike.
: *compile r> dup @ , cell+ >r ;

: compile,	, ;
: [compile] ' compile, ; IMMEDIATE

: [']
  ' [compile] literal ; IMMEDIATE

\ Char handling
: char		parse-word drop c@ ;
: [char]	char [compile] literal ; IMMEDIATE

\ *** Control structures ***
\ condition IF truepart THEN rest
\ 		--> condition 0branch [offset] truepart rest
\ 		where offset is the offset of rest
\ condition IF truepart ELSE elsepart THEN rest
\ 		--> condition 0branch [offset0] truepart branch [offset1] elsepart rest
\ 		where offset0 is the offset of falsepart and offset1 is the offset of rest

: forward,	( -- addr )		\ Compile a forward offset reference (push here, compile dummy offset)
	here 0 ,
;

: resolve-offset	( addr -- )		\ Resolve a previous forward offset
	here over - swap !
;

: if
	*compile 0branch	\ Compile 0branch
	forward,
; IMMEDIATE

: then
	resolve-offset
; IMMEDIATE

\ Note that the THEN word is identical between if and else - so else needs to
\ leave things in the state that IF does, ie. the addr of an offset to backpatch
\ on the dstack
: else
	*compile branch
	forward,
	swap						( offset-else ) \ Backfill the original IF offset
	resolve-offset
; IMMEDIATE

\ ** Looping constructs
: begin
  here			\ Remember loop start
; IMMEDIATE

: until
  *compile 0branch
  here -
  ,
; IMMEDIATE

: while
	*compile 0branch
	forward,
; IMMEDIATE

: repeat		\ ( bloc wloc -- )
  swap			\ ( wloc bloc )
  *compile branch
  here -		\ ( wloc offset )
	,				  \ ( wloc )
	resolve-offset
; IMMEDIATE

\ RECURSE makes a recursive call to the word that's currently being compiled.
\   Get the latest word created, move to its cfa, and compile that
: recurse
  latest >cfa compile, ; IMMEDIATE

  \ -- addr u
: s"
  '"' parse
  state @ if
	\ Compiling
	[compile] sliteral
  then
; IMMEDIATE

\ 0= if <perror> then ...
: abort"
  *compile 0branch
	[compile] if
	[compile] s"
  *compile type
  *compile cr
	*compile abort
	[compile] then
; IMMEDIATE

\ POSTPONE compiles a call to the following word, whether it is an immediate word or not.
: postpone
  parse-word 2dup find-word	\ ( -- addr u 0 | xt 1 | xt -1 )
  ?dup 0= if
	type ' ' emit true abort"  postpone?"
  then

  \ xt +- 1
  0> if
	\ Immediate word
	compile,
  else
	\ Non immediate
	[ ' literal compile, ]
	['] compile, compile,
  then
  2drop
; IMMEDIATE

\ NOT (boolean)
: not 0= ;

: unless
  postpone not
	postpone if
; IMMEDIATE

\ Read the next chr from the input source
\ ( -- char flag ) Flag is true if char is valid, false if we hit the end of input.
: inch >in @ in@ in+ ;

\ Implement nestable paren comments. This scans the input forward using inch, keeping a count of
\ seen ( characters, and watching for the equivalent number of ).
: (
  1
  begin
	inch if				\ Get next chr is it valid?
	  dup '(' = if		\ If open paren, increment count
		drop
		1+
	  else				\ If close paren, decrement count
		')' = if
		  1-
		then
	  then
	else				\ If chr not valid, bail immediately by resetting count
	  drop 0
	then
  dup 0= until
  drop
; IMMEDIATE

( We now (have ((nested)) comments!) Yay!)

: wrds	( n -- 2n )	\ Words are 2 bytes ie c shorts
  2*
;

: longs ( n -- 4n )	\ Longs are C 32 bit ints
  4*
;

: xlongs ( n -- 8n )	\ Xlongs are C 64 bit ints
  8*
;

: w,	( half -- )	here [ 1 wrds ] literal allot w! ;
: l,	( word -- )	here [ 1 longs ] literal allot l! ;

( addr u -- ) \ Compile the given string directly at HERE
: compile-str
  here				( addr u haddr )
  over allot align	( addr u haddr )
  swap cmove
;

: *emit-next 	   $next	 compile-str ;
: *emit-doesbody $dodoes compile-str ;
: *fix-cfa r> latest >cfa ! ;

\ does> creates a "defining word." A defining word, when executed, will create a new definition,
\ then emit a code sequence causing a jump from that word to the code sequence following the does>.
: does>
  postpone  *fix-cfa
  *emit-doesbody
; IMMEDIATE

: hide-name
  parse-word 2dup find-word		( addr u 0 | xt 1 | xt -1 )
  ?dup if						( addr u | xt )
	drop
	cfa>
	toggle-hide
	2drop
  else
	type
	' ' emit
	0 abort" unknown in hide-name"
  then
;

\ ** Variables, constants, values etc.

: 2! ( x1 x2 addr -- )	tuck !	cell+ ! ;
: 2@ ( addr -- x1 x2 )	dup cell+ @ swap @ ;

: variable	create 1 cells allot ;
: 2variable	create 2 cells allot ;
: wordlist	( -- wid )	here 1 cells allot ;

:  constant	variable  latest >cfa >body  ! does> @ ;
: 2constant	2variable latest >cfa >body 2! does> 2@ ;

: buffer: ( amt -- addr )
	create allot align
;

: value constant ;
: to
  ' >body
  state @ if
	[compile] literal
	postpone !
  else
	!
  then
; IMMEDIATE

: to
  ' >body
  state @ if
	[compile] literal
	postpone +!
  else
	+!
  then
; IMMEDIATE

$20 constant	f_hidden
$40 constant	f_builtin
$80 constant	f_immediate
$1F constant	f_len_mask

\ **** DO, ?DO, LOOP, +LOOP
create		do-stack 8 cells allot
variable	do-sp	 0 do-sp !
  : do-addr	do-stack do-sp @ cells + ;

  : >do     do-addr ! 1 do-sp +! ;
  : do>		-1 do-sp +! do-addr @ ;

: do	( limit base -- )
		( c: -- do-token )
		( do-stack: -- leave-token )
	postpone 2>r	( we implement cstack with our return stack - separate c-stack might be faster? )
	0 >do here		( do-token )
; IMMEDIATE

: unloop	( r: inc limit index -- )
  r> 2r> 2drop >r
;

( Push the current leave token on the do stack
  onto the leave linked-list at here.
  Replace current leave token with here.
)
: push-leave
  here do>
  , >do
;

: ?do	( limit base -- )
	  	( c: -- do-token )
	  	( do-stack: -- leave-token )
  postpone 2dup
  [compile] do
  postpone <>
  postpone 0branch
  push-leave
  drop here
; IMMEDIATE

: leave
  postpone branch
  push-leave
; IMMEDIATE

\ fix up the given leave token and return the next
: fix-leave		( leave-token -- leave-token' )
  dup @ swap	( leave-token' leave-token )
  here over		( leave-token' leave-token here leave-token )
  - swap !		( leave-token! )
;

: loop-impl
  postpone 0branch
  here				( do-token here )
  -					( byte offset )
  ,

  \ Fix linked list of leave-tokens
  do> 		( leave-token )
  begin
	?dup while
	fix-leave
  repeat
  postpone 2r>
  postpone 2drop
;

: loop
  postpone looptest
  loop-impl
; IMMEDIATE

: +loop
  postpone +looptest
  loop-impl
; IMMEDIATE

\ ****Misc math and convenience

: decimal 10 base ! ;
: hex     16 base ! ;

\ Return the width in characters of an unsigned number in the current base
\ ( u -- width )
: uwidth
  base @ u/
  ?dup if
	recurse 1+
  else
	1
  then
;

: d0= ( xd -- flag )	or 0= ;
: s>d ( n -- d )		dup 0< ;

: */mod  ( n1 n2 n3 -- rem quot )	>r m* r> sm/rem ;
: */     ( n1 n2 n3 -- quot )		*/mod nip ;

: signum	\ x -- -1/0/1
	dup 0< swap 0> - ;

: depth
  stack drop - 1 cells / ;

: count	\ caddr -- addr' ch
  dup 1+ swap c@ ;

: /string		\ ( addr u n -- addr' u' )
  tuck -
  >r + r>
;

\ *** Printing

: char+		( addr -- addr' )	1+ ;
: chars		( m -- n )	;

\ PAD
256 constant pad-size
here pad-size allot value pad

: ."
  postpone s"
  state @ if
	postpone type
  else
	type
  then
; IMMEDIATE

\ **** Exceptions
cr .( Exceptions...)

variable _handler 0 _handler !

: catch		( xt -- exn? )
  dsp@ >r
  _handler @ >r		\ Save dsp and prev handler
  rsp@ _handler !	\ Addr of return addr
  execute			\ Execute returns if no throw
  r> _handler !		\ Restore prev handler
  r> drop			\ Discard saved SP
  0					\ Flag "no throw"
;

: throw		( n -- )
  ?dup if
	_handler @
	?dup if
		rsp!	\ Restore prev return stack
		r> _handler !	\ Restore prev handler
		r> swap >r		\ Exc# on return stack
		dsp! drop r>	\ restore stack
		\ Return to the caller of CATCH because return stack is restored to the state
		\ when catch executed
	else
	  \ No handler, uncaught exception
	  dup -1 = if
		." Uncaught abort" cr
		abort		\ Call 1st abort implemented
	  else
		." Uncaught exception" cr
	  then
	then
  then
;

\ Redefine abort in terms of throw; note that we also have to redefine abort"
\ since it references the old abort.
: abort
  -1 throw
;

\ 0= if <perror> then ...
: abort"
  postpone 0branch
  here
  0 ,
  [compile] s"
  postpone type
  postpone cr
  postpone abort
  here
  over -
  swap !
; IMMEDIATE

\ *** Printing numbers
cr .( Printing... )

: cells+ ( x n -- x+n cells )	cells + ;

\ Print the name of a word given its lfa
: id.	( addr -- )
  >name				( nfa )
  dup				( nfa nfa )
  c@ F_LEN_MASK and	( nfa len )
  dup 15 > >r
  15 min
  swap 1+ swap		( nfa+1 len )
  type
  r> if '+' emit then
  bl emit
;

: ?word-flag	( lfa wf -- flag )
  swap >name	( wf naddr )
  c@			( wf flagbyte )
  and 0<>		( true iff wf @ flagbyte )
;

: ?hidden	( lfa -- flag )
  F_HIDDEN ?word-flag
;

: ?builtin	( lfa -- flag )
  F_BUILTIN ?word-flag
;

: ?immediate	( lfa -- flag )
  F_IMMEDIATE ?word-flag
;

: words		( -- )
  latest
  begin
	?dup
  while
	dup ?hidden unless
	  dup id.
	then
	@
  repeat
  cr
;

: codepage create align
	\ The individual values will be backwards on the stack, ie. the 255th cp is first
	256 0 do
	  w,
	loop

	does>
	( cp addr -- unicode )
	swap $ff swap - 2* + w@
;

\ Only one we currently define is the IBM / DOS codepage (codepage 437, from wikipedia)
hex
0020 263A 263B 2665 2666 2663 2660 2022 25d8 25c8 25d9 2642 2640 266a 266b 263c  \ 0x / 0
25ba 25c4 2195 203c 00b6 00a7 25ac 21ab 2191 2193 2192 2190 221f 2194 25b2 25bc  \ 1x / 16
0020 '!'  '"'  '#'  '$'  '%'  '&'  '''  '('  ')'  '*'  '+'  ','  '-'  '.'  '/'   \ 2x / 32
'0'  '1'  '2'  '3'  '4'  '5'  '6'  '7'  '8'  '9'  ':'  ';'  '<'  '='  '>'  '?'   \ 3x / 48
'@'  'A'  'B'  'C'  'D'  'E'  'F'  'G'  'H'  'I'  'J'  'K'  'L'  'M'  'N'  'O'   \ 4x / 64
'P'  'Q'  'R'  'S'  'T'  'U'  'V'  'W'  'X'  'Y'  'Z'  '['  '\'  ']'  '^'  '_'   \ 5x / 80
'`'  'a'  'b'  'c'  'd'  'e'  'f'  'g'  'h'  'i'  'j'  'k'  'l'  'm'  'n'  'o'   \ 6x / 96
'p'  'q'  'r'  's'  't'  'u'  'v'  'w'  'x'  'y'  'z'  '{'  '|'  '}'  '~'  2302  \ 7x / 112
00c7 00fc 00e9 00e2 00e4 00e0 00e5 00e7 00ea 00eb 00e8 00ef 00ee 00ec 00c4 00c5  \ 8x / 128
00c9 00e6 00c6 00f4 00f6 00f2 00fb 00f9 00ff 00d6 00dc 00a2 00a3 00a5 20a7 0192  \ 9x / 144
00e1 00ed 00f3 00fa 00f1 00d1 00aa 00ba 00bf 2310 00ac 00bd 00bc 00a1 00ab 00bb  \ Ax / 160
2591 2592 2593 2502 2524 2561 2562 2556 2555 2563 2551 2557 255d 255c 255b 2510  \ Bx / 176
2514 2534 252c 251c 2500 253c 255e 255f 255a 2554 2569 2566 2560 2550 256c 2567  \ Cx / 192
2568 2564 2565 2559 2558 2552 2553 256b 256a 2518 250c 2588 2584 258c 2590 2580  \ Dx / 208
03b1 00df 0393 03c0 03a3 03c3 00b5 03c4 03a6 0398 03a9 03b4 221e 03c6 03b5 2229  \ Ex / 224
2261 00b1 2265 2264 2320 2321 00f7 2248 00b0 2219 00b7 221a 207f 00b2 25a0 00a0  \ Fx / 240
decimal
codepage cp437

variable current-codepage ' cp437 current-codepage !

: char-to-unicode		( char -- codepoint )
  current-codepage @ execute
;

: utfbyte ( chr bits -- )
  dup
  1 swap lshift 1 -	( chr bits mask )
  rot and			( bits masked )
  %10				( bits masked 10 )
  rot lshift or
;

\ Encode 16 bit val to utf8 and emit the sequence
: uemit			( u -- )
  char-to-unicode
  2 base !
  dup $7f <= if
	emit
  else
	>r
	r@ $7ff <= if
		( two byte encoding )
		r@ 6 utfbyte		  ( chr byte2 )
		r@ 6 rshift 5 utfbyte ( byte2 pbyte1 )
		%10000000 or		  ( byte2 byte1 )
		emit emit
	else
	  r@ $FFFF <= if
		( three byte encoding )
		r@  6 utfbyte
		r@  6 rshift 6 utfbyte
		r@ 12 rshift 4 utfbyte
		%11000000 or
		emit emit emit
		else
			( four byte encoding )
			r@  6 utfbyte
			r@  6 rshift 6 utfbyte
			r@ 12 rshift 6 utfbyte
			r@ 18 rshift 3 utfbyte
			%11100000 or
			emit emit emit emit
		then
	 then
	 r> drop
  then
  10 base !
;

: urepchar ( ucp n -- )
  dup 0> if
	0 do
	  dup uemit
	loop
  else
	drop
  then
  drop
;

\ ** Pictured and numeric output

\ PIC
300 aligned constant pic-size

here pic-size allot pic-size +
value picend
variable pic		0 pic !
variable inpic		false inpic !

\ Double to double division - used by pictured output
: uml/mod
  dup >r
  0 swap um/mod
  r> swap >r
  um/mod
  r>
;

: ?in-pic	( -- ) \ Throw if not in pictured output
  inpic @ 0= if
	." Pictured output word used outside <# #>"
	-21 throw
  then
;

: hold			( ch -- )
  ?in-pic
  pic @			(  )
  1-
  tuck
  c!
  pic !
;

: <#	( -- )
  picend pic !
  1 inpic +!
;

: digit 	( n -- char )	\ Convert a num to a digit (incorrect for values > 36)
  9 over < if		\ 0 -> 48   10 -> 65
	7 +
  then
  '0' +
;

: ldigit 	( n -- char )	\ Convert a num to a digit (incorrect for values > 36)
  9 over > if		\ 0 -> 48   10 -> 97
	39 +
  then
  '0' +
;

: #			( ud -- ud' )
  ?in-pic
  base @
  uml/mod
  rot
  digit hold
;

: #s		( ud -- 0 )
  ?in-pic
  begin
	#
	2dup
	d0=
  until
;

: sign		( n -- )
  ?in-pic
  0< if
	'-' hold
  then
;

: #>
  ?in-pic
  2drop
  pic @
  picend
  over -
;

: #dsign		( n du -- ) \ Convert an unsigned double to a string, prepending a - sign if n < 0
  <#
  #s
  rot sign
  #>
;

: #str			( n -- caddr u )	\ Convert n to a string (signed)
  dup abs 0
  #dsign
;

: #ustr			( n -- caddr u )	\ Convert n to a string (signed)
  0 tuck
  #dsign
;

: #dstr			( n -- caddr u )	\ Convert n to a string (signed)
  tuck dabs
  #dsign
;

: #udstr			( n -- caddr u )	\ Convert n to a string (signed)
  0 -rot
  #dsign
;

: u.			( u -- )
  #ustr type space
;

: d.			( d -- )
  #dstr type space
;

: ud.			( d -- )
  #udstr type space
;

: repchar	( char n -- )
  dup 0>	( char n flag )
  if
	0 do	( char )
		dup emit
	loop
  else
	drop
  then
  drop
;

: zeroes	( n -- )
  '0' swap repchar
;

: spaces	( n -- )
  bl swap repchar
;

\ Print a number right justified in a field of width chars. xt is expected to print the padding.
: xud.r	( ud width xt -- )
  >r				( ud width )
  -rot #udstr		( width caddr u )
  rot over -
  r> execute
  type
;

: xd.r	( ud width xt -- )
  >r				( ud width )
  -rot #dstr		( width caddr u )
  rot over -
  r> execute
  type
;

\ Print a number right justified in a field of width chars. xt is expected to print the padding.
: xu.r	( u width xt -- )
  >r				( u width )
  swap #ustr		( width caddr u )
  rot over -		( caddr u n )
  r> execute
  type
;

: x.r	( ud width xt -- )
  >r			( ud width )
  swap #str		( width caddr u )
  rot over -	( caddr u n )
  r> execute
  type
;

: d.r			( u wid -- )
  ['] spaces	( u wid xt )
  xd.r ;

: d.0r
  ['] zeroes
  xd.r ;

: ud.r			( u wid -- )
  ['] spaces	( u wid xt )
  xud.r ;

: ud.0r
  ['] zeroes
  xud.r ;

: u.r			( u wid -- )
  ['] spaces	( u wid xt )
  xu.r ;

: u.0r
  ['] zeroes
  xu.r ;

: .r
  ['] spaces
  x.r ;

: .0r
  ['] zeroes
  x.r ;

: .
  base @ 10 = if
	#str
  else
	#ustr
  then
  type space
;

: x.
	base @
	hex
	swap .
	base swap !
;

\ Non destructively print the stack
: .s
  dsp@
  begin
	dup s0 @ <
  while
	dup @ u.
	space
	8+
  repeat
  cr
  drop
;

variable basehold
: .2s base @ basehold ! 2 base ! .s basehold @ base ! ;
: .xs base @ basehold ! hex .s basehold @ base ! ;

\ ** Assertions
: averts
	parse-word 2dup find-word	\ ( -- addr u 0 | xt 1 | xt -1 )
	?dup 0= if
		type ' ' emit true abort"  averts?"
	then
	drop
	nip nip
	state @ if
		postpone 0=
		postpone 0branch
		here 0 ,
		swap postpone literal
	  postpone execute
		-20 postpone literal
		postpone throw
		here over - swap !
	else
		swap 0= if
			execute
			-20 throw
		else
			drop
		then
	then
; IMMEDIATE

: triggers		( flag "<name>" -- )
	parse-word 2dup find-word	\ ( -- addr u 0 | xt 1 | xt -1 )
	?dup 0= if
		type ' ' emit true abort"  triggers?"
	then
	drop
	nip nip
	state @ if
		postpone 0<>
		postpone 0branch
		here 0 ,
		swap postpone literal
		 postpone execute
		-20 postpone literal
		postpone throw
		here over - swap !
	else
		swap 0<> if
			execute
			-20 throw
		else
			drop
		then
	then
; IMMEDIATE

: ? ( addr -- ) @ . ;

: dump-xline		( addr n -- )
	base @ -rot	( base addr n -- )
	hex

	?dup if
	over		( base addr n addr )
	16 u.r space			\ Print addr

	dup			( base addr n n )
	8/
	0 ?do		( base addr n )
	  over i cells +	( base addr n addr+i )
	  @		( base addr n byte )
	  16 u.0r space
	loop

	\ Print ascii equivalents
	dup			( base addr n n )
	3 *		  ( base addr n spc )

	\ Pad to char location


	[ 16 3 * ] literal	( base addr n spc bspc )
	swap -
	spaces			( base addr n )
	0 ?do
	  dup i +		( base addr addr+i )
	  c@			( base addr byte )
	  dup 1 >= if
		uemit
	  else
		drop '.' emit
	  then
	loop
	then
	drop
	base !
;

: dump-line		( addr n<=16 -- )
  base @ -rot	( base addr n -- )
  hex

  ?dup if
	over		( base addr n addr )
	16 u.r space			\ Print addr

	dup			( base addr n n )
	0 ?do		( base addr n )
	  over i +	( base addr n addr+i )
	  c@		( base addr n byte )
	  2 u.0r space
	loop

	\ Print ascii equivalents
	dup			( base addr n n )
	3 *		    ( base addr n spc )

	\ Pad to char location


	[ 16 3 * ] literal	( base addr n spc bspc )
	swap -
	spaces			( base addr n )
	0 ?do
	  dup i +		( base addr addr+i )
	  c@			( base addr byte )
	  dup 1 >= if
		uemit
	  else
		drop '.' emit
	  then
	loop
  then
  drop
  base !
;

: dump 			( addr len -- )
  16 /mod				( addr len%16 len/16 -- )
  swap >r				( addr len/16 -- r: len%16 )

  dup
  0 ?do
	over i 16 * +		( len addr daddr )
	16 dump-line cr		( len addr )
  loop

  \ Dump a possible partial ending line
  16 *	+				( addr len )
  r> 					( len%16 addr-start )
  dump-line cr
;

: xdump 			  ( addr len -- )
	aligned
	16 /mod				( addr len%16 len/16 -- )
	swap >r				( addr len/16 -- r: len%16 )

	dup
	0 ?do
	over i 16 * +		( len addr daddr )
	16 dump-xline cr		( len addr )
	loop

	\ Dump a possible partial ending line
	16 *	+				( addr len )
	r> 					( len%16 addr-start )
	dump-xline cr
;

: find-word-protected		( msg n -- )
  parse-word 2dup find-word	( msg n addr n 0|xt 1|xt -1 )
  ?dup 0= if
	." Word <"
	type
	." > not found: "
	type cr
	abort
  then		( msg n addr n xt )
  drop
  >r
  2drop
  2drop
  r>
;

: ascii
  base @
  decimal
  ."     0 1 2 3 4 5 6 7 8 9 A B C D E F" cr
  256 0 do
	i 16 mod 0= if
	  cr
	  hex
	  i 2 u.r
	  decimal
	  ." : "
	then
	i uemit space
  loop
  cr
  base !
;

: forget
  s" forget" find-word-protected
  cfa>
  dup	?builtin if
	drop
	abort" Can't forget builtin word."
  then
  dup @			( prev lfa )
  get-current !	( Update latest to prev word from forgotten )
  cp !			( Update here )
;

( Returns the depth of the dstack in words )
: depth
  s0 @ dsp@ -
  8 -			\ Because S0 was on the stack when we pushed DSP
  8/
;

\ **** CASE ... OF
cr .( case ... of...)

: case
  0			\ marker for bottom of stack
; IMMEDIATE

: of
	  postpone over
	  postpone =
	  [compile] if
	  postpone drop
; IMMEDIATE

: endof
  [compile] else
; IMMEDIATE

: endcase
  postpone drop
  begin
	?dup
  while
	[compile] then
  repeat
; IMMEDIATE

\ Test exceptions
: _foo-throw throw ;

: _test-exceptions
  25 ['] _foo-throw catch
  ?dup if
	cr ." Called _foo-throw and it threw exception number: " . cr
	drop	\ The argument of foo
  then
  0 ['] _foo-throw catch
  ?dup 0= if
	cr ." Called _foo-throw and it didn't throw, as exepcted." cr
  then

  1 _foo-throw
;

: maybe-test-exceptions
	\ Don't have conditional compilation yet
	run-tests @ if
		cr .( test-exceptions... )
		_test-exceptions
	then
;

' maybe-test-exceptions catch drop

\ **** Search Order / word / find / find-name / etc
cr .( Search order... )

: wordlist \ -- wid
  here 1 cells allot dup 0 swap !
;

: set-current ( wid -- )	current ! ;

get-current constant	forth-wordlist
wordlist    constant	environment

16 constant max-orders
create search-context max-orders cells allot
variable #search-context	0 #search-context !

get-current constant forth-wordlist
wordlist    constant internal


: default-context	( -- forth-wordlist ... widn n )
	is-compiling-rc @ if
		forth-wordlist
		internal
		2
	else
		forth-wordlist
		1
	then
;

: get-order	( -- widl ... widl n )
  #search-context @ 0 ?do
	#search-context @ i - 1- cells search-context + @
  loop
  #search-context @
;

: set-order ( widl ... widn n | -1 )
  dup -1 = if
	\ Push default wordlists
	drop
	default-context
  then

  dup #search-context !
  0 ?do i cells search-context + ! loop
;

\ Initialize to default-context
-1 set-order

\ Given a nt, return the string name of the word represented
\ by that dict entry.
: name>string		( nt -- caddr u )
	c@ f_len_mask and
  swap 1+ swap
;

\ *** Search order compliant find-name / find

: word \ char "<chars>ccc<char>" -- caddr
  dup dup 1+ skip			\ Skip leading delimiter(s)
  dup 1+ swap parse-token	\ Grab word ( low hi -- addr u )
  >r here 1+ r@ cmove		\ Word will be copied to here+1 .. here+(len+1), 1st byte reserved for count
  r> here c!				\ Store count
  here
;

create _wordbuf_1	64	allot	_wordbuf_1 64 erase
create _wordbuf_2	64	allot	_wordbuf_2 64 erase

: setup-wordbufs	( addr u -- )	\ wb 1 has default case, wb 2 has downcased words
  2dup				( addr u addr u )
  _wordbuf_1 -rot	( addr u dst addr u )
  $toscs
  _wordbuf_2 -rot	( dst addr u )
  $toscs
  _wordbuf_2 stolower
;

: $find-name-in			( wid -- nt | 0 )	\ Assumes wordbuf 1 and 2 are set up
  >r
 _wordbuf_2 _wordbuf_1	( lowered normal )
  ['] matchxt			( lowered normal xt )
	r>						  ( lowered normal xt wid )
	exec-wordlist		( lowered normal 0 | xt 1 | xt -1 )
  ?dup if
	2swap 2drop
	swap xt>nt nip
  else
	2drop drop
	0
  then
;

: find-name-in			( caddr u wid )
  -rot setup-wordbufs
  $find-name-in
;

: find-name			( c-addr u -- nt 1 | nt -1 | 0 )
  setup-wordbufs	( -- )
  get-order			( widn ... widi n )
  0 swap			( widn ... widi 0 n )
  0 ?do				( widn...widi 0 )
	dup 0= if
	  drop $find-name-in
	else
	  nip
	then
  loop
;

: find-xt			( 0 | xt 1 | xt -1 )
  find-name		( nt | 0 )
  dup 0<> if
	dup name>	( nt lfa )
	?immediate if
	  1
	else
	  -1
	then
	swap name>compile swap
  then
;

\ Swap everything over to use the dictionary find-word
' find-xt find-word-vec !

: find			( caddr -- caddr 0 | xt )
  dup >r
  count find-name
  ?dup if
		state @ if
			name>compile
		else
			name>interpret
		then
  else
		r@ 0
  then
  r> drop
;

: discard	( x1 .. xn u -- ) \ Drop u+1 stack items
  0 ?do drop loop
;

: definitions	( -- )
  get-order swap set-current 1- discard
;

: also	( -- )
  get-order over swap 1+ set-order
;

: (wordlist) ( wid "<name>" -- ; )
  create ,
  does>
	@ >r
	get-order nip
	r> swap set-order
;

forth-wordlist (wordlist) forth

: only	( -- )	-1 set-order ;

: previous ( -- )
  get-order
  nip 1- set-order ;

\ Handy word for pushing a wid onto the search order
: >order
  >r get-order r> swap 1+ set-order
;

\ Enough space to hold a max length counted string
create _word-buf 257 allot align

: word ( char -- c-addr )	\ Parse word delimited by char.
  dup bl = if				\ If parsing blank separated, the standard suggests that 0 .. 32 should be sckipped but it isn't clear
		drop
		parse-word
  else
		dup dup 1+ skip
		dup 1+ swap parse-token
  then
  >r _word-buf 1+ r@ cmove
  r@ _word-buf c!
  _word-buf r> + bl c!	\ Trailing blank
  _word-buf
;

: internal-defs
	internal set-current
;

: public-defs
	forth-wordlist set-current
;

cr .( Environment... )

environment set-current
: /counted-string		255 ;
: /hold					pic-size ;
: /pad					pad-size ;
: address-unit-bits		8 ;
: core					true ;
: core-ext				false ;
: floored				false ;
: max-char				255 ;
: max-d					-1 -1 1 rshift ;
: max-n					$7fffffffffffffff ;
: max-u					-1 ;
: max-ud				-1 -1 ;
: return-stack-cells	rstack nip nip 1 cells / ;
: stack-cells			stack nip nip 1 cells / ;
: version				version @ ;
forth-wordlist	set-current

: environment?	( c-addr u -- false | i*x true )
  environment search-wordlist if
	execute
	true
  else
	false
  then
;

\ *** Simple string buffer
.( Strings... )

256 buffer: strcat-buf

internal-defs
variable strcat-buf-pos
public-defs

: strcat-reset
	0 strcat-buf-pos !
;

strcat-reset

: strcat-add		( addr u -- )
	strcat-buf strcat-buf-pos @ + ( addr u dest )
	swap dup >r cmove
	r> strcat-buf-pos +!
;

: strcat-str
	strcat-buf strcat-buf-pos @
;

: constant-with-name		( val addr u -- )	\ Create a new constant at runtime w/the given name in the current dict
	\ There's no doubt a better way to do this. *create (build>) followed by direct compilation
	strcat-reset
	rot #ustr strcat-add
	s"  constant " strcat-add
	strcat-add
	strcat-str evaluate
;

\ *** Interpret time if/then

cr .( [if] [else] [then]... ) cr

: [else]	( -- )
  1 begin									\ level
	begin bl word count dup while			\ level adr len
	  2dup s" [if]" cicompare 0= if
		2drop
		1+									\ level'
	  else									\ level adr len
		2dup s" [else]" cicompare 0= if
		  2drop
		  1-
		  dup if 1+ then					\ level'
		else
		  s" [then]" cicompare 0= if		\ level
			1-								\ level'
		  then
		then
	  then ?dup 0= if exit then				\ level'
	repeat 2drop
  refill 0= until
  drop
; IMMEDIATE

: [if]		( flag -- )
  0= if postpone [else] then
; IMMEDIATE

: [then]	( -- )
; IMMEDIATE

: [defined]
  bl word find nip 0<>
; IMMEDIATE

: [undefined]
  bl word find nip 0=
; IMMEDIATE

\ **** Structures
.( Structures...) cr

: begin-structure	( -- )
	create
	here 0 0 ,		\ Mark stack, lay dummy
	does> @
;

: +field		\ n "name" -- ; Exec: addr -- 'addr
  create over , +
  does> @ +
;

: field:
  aligned [ 1 cells ] literal +field
;

: wfield:
  1 #aligned [ 1 wrds ] literal +field
;

: lfield:
  2 #aligned [ 1 longs ] literal +field
;

: xfield:
  3 #aligned [ 1 cells ] literal +field
;

: end-structure		( addr n -- )
  swap !
;

\ **** Namespaced-field structures

internal-defs
.( Named structures...) cr
: +context:	( "name" wid -- )
  create immediate ,
  does>
  @ ( wid ) >order
;
public-defs

\ Make a new word list for the struct's field definitions expected to follow.
\ Pushes to the top of the search order + definitions so field defs go in this
\ wlist.
: struct:		( "name" -- wid 0 )	( order: -- wid )
  get-current	( wid ) 0
  wordlist
  dup +context:
  >order
  definitions ( wid 0 )
  s" : } previous ; immediate" evaluate
;

: '}'eval ( -- )
  s" }" evaluate
;

\ Terminate a structure definition begun with struct:'
\ 1) define "/struct", the structure size constant, in the struct namespace
\ 2) Restore the search order and compilation wlst to that just before the
\    invocation of "struct:"
: ;struct		( wid u -- )
  aligned
  s" constant /struct" evaluate
  ( wid ) set-current
  '}'eval
;

run-tests @ [if]		\ Tests
cr .( Namespaced struct tests...)
struct: person{
2 cells +field name
1 chars +field gender aligned
1 cells +field age
;struct

struct: girl{
person{
  /struct +field self
  /struct +field friend1
}
1 cells +field friend2
2 cells +field favdrink
;struct

create george person{ /struct } allot
create marie  girl{ /struct }   allot

: name1 s" Marie" ;
: name2 s" Bill" ;
: name3 s" George" ;
: drink1 s" cranberry juice" ;

name1	marie girl{ self person{ name } }		2!
'F'     marie girl{ self person{ gender } }		c!
23		marie girl{ self person{ age } }		!

name2	marie girl{ friend1 person{ name } }	2!
'M'     marie girl{ friend1 person{ gender } }	c!
25		marie girl{ friend1 person{ age } }		!

george	marie girl{ friend2 } !

name3	george	person{ name }		2!
'M'		george	person{ gender }	c!
21		george	person{ age }		!

drink1	marie	girl{ favdrink }	2!

: .gender ( char --)
  case
	'M' of	." male"	endof
	'F' of	." female"	endof
	." unspecified"
  endcase
;

: .. '.' emit ;


: show-girl	( instance -- )
cr ." Her name is "
	dup girl{ self person{ name } } 2@ type ..
cr ." Her gender is "
	dup girl{ self person{ gender } } c@ .gender ..
cr ." Her age is "
	dup girl{ self person{ age } } @ 2 .r ..
cr ." Her favorite drink is "
	dup girl{ favdrink } 2@ type ..
cr ." Friend #1's name is "
	dup girl{ friend1 person{ name } } 2@ type ..
cr ." Friend #1's gender is "
	dup girl{ friend1 person{ gender } } c@ .gender ..
cr ." Friend #1's age is "
	dup girl{ friend1 person{ age } } @ 2 .r ..
cr ." Friend #2's name is "
	dup girl{ friend2 } @ person{ name } 2@ type ..
cr ." Friend #2's gender is "
	dup girl{ friend2 } @ person{ gender } c@ .gender ..
cr ." Friend #2's age is "
		girl{ friend2 } @ person{ age } @ 2 .r .. bl emit
;

cr cr .( Here's Marie!)

marie show-girl
cr .( To see structure field names, execute:)
cr .(   "person{ words }" and "girl{ words }".)
cr

[then]

: see		( "<name>" -- )
	parse-word find-xt dup 0= abort" Word not found."
	swap

	dup
	cfa> ." : " id.
	cell+		\ Skip cf

	\ We have the XT of the word in question now
	begin
		dup @	['] exit <>
	while
		dup @
		case
		['] branch of ." branch( " cell+ dup @ 8/ . ." ) " endof
		['] 0branch of ." 0branch( " cell+ dup @ 8/ . ." ) " endof
		['] lit of cell+ dup @ . endof
		['] sbranch of ." s" '"' emit bl emit \ sliteral -> broff <str>
								cell+ dup @ +							\ Skip past str, next words are <lit> addr <lit> n
								cell+ dup @ >r
								cell+ cell+ dup @ r> swap type
								'"' emit bl emit
								endof
		dup cfa> id.
		endcase
		cell+
	repeat
	drop
	." ;"
	0> if ." IMMEDIATE"
	then
	cr
;

\ **** Lambdas
.( Lambdas... ) cr
: [:
	\ Compile the following structure:
	\ <branch>
	\ offset to lit xt push
	\ DOCOL		<- XT of Lambda
	\ ... Lambda code ...
	state @
	postpone branch
	forward,
	*docol ,
	]
; IMMEDIATE

: ;]
	\ Complete lambda definition:
	\ <branch target> LIT <addr of docol>
	\ ... Normal compilation continues

	\ On stack: addr of back ref jump offset
	postpone exit
	dup resolve-offset		( addr )  \ Back patch
	cell+								  ( addr' ) \ Skip to xt
	over if
	  [compile] literal
	else
		swap
	then
	state !
; IMMEDIATE

run-tests @ [if]
: twrd dup ?dup if id. false else true then ;

: test-lambda-word
	." Testing lambdas - should have output similar to 'words':" cr
	[:
	dup ?dup if id. false else true then
	;]	get-current exec-wordlist drop
	cr
;

test-lambda-word
.( testing outer lambda.. ) cr

[: ." Testing lambda outside colon def" cr ;] execute
[: ." Testing nested lambda (outside colon def):" [: ." Inner!" cr ;] execute ;] execute

.( Do does experiment)
: lambda-tbl		( cnt -- )
	create
	0 ?do , loop
	does> swap cells + @ execute ;

[: ." One" cr ;]
[: ." Two" cr ;]
[: ." Three" cr ;]
[: ." Four" cr ;]
[: ." Five" cr ;]
5 lambda-tbl testtbl

3 testtbl
0 testtbl
4 testtbl
2 testtbl
[then]

\ **** Modules
.( Modules...) cr

internal-defs

5 constant mod-stk-count
16 constant max-order

variable mod-stk-idx

begin-structure mod-ent-size
	field: module-count
	field: module-base
	field: module
	field: mod-old-current
end-structure

mod-ent-size mod-stk-count * buffer: module-stack

public-defs

: x-stk-overflow ." module stack overflow" cr ;
: x-stk-underflow ." module stack underflow" cr ;
: x-ord-overflow ." wordlist order overflow" cr ;
: x-defined ." module already defined" cr ;
: x-not-found ." module not found" cr ;
: x-tok-expected ." token expected" cr ;

internal-defs

: module-stack@
	mod-stk-idx @ 0<> if
		module-stack mod-stk-idx @ 1- mod-ent-size * +
	else
		0
	then
;

: push-stack	( wid -- )
	mod-stk-idx @ mod-stk-count < averts x-stk-overflow
	1 mod-stk-idx +!
	module-stack@
	0 over module-count !
	base @ over module-base !
	get-current over mod-old-current !
	over set-current
	module !
;

: drop-stack
	mod-stk-idx @ 1 > averts x-stk-underflow
	module-stack@
	dup mod-old-current @ set-current
	module-base @ base !
	get-order module-stack@ module-count @
	begin dup 0<> while
		1- swap 1- swap rot drop
	repeat
	drop
	set-order
	-1 mod-stk-idx +!
;

\ Add a wordlist to the search order
: add	( wid )
	>r get-order dup max-order < r> swap averts x-ord-overflow
	module-stack@ module-count @ 0<> if
		rot drop swap module-stack@ module @ swap 1+ set-order
	else
		swap 1+ set-order
	then
	mod-stk-idx @ 0<> averts x-stk-underflow
	module-stack@
	1 swap module-count +!
;

\ Remove a wordlist from the search order
: remove ( wid -- )
	mod-stk-idx @ 0 > averts x-stk-underflow
	>r get-order module-stack@ module-count @
	begin dup 0<> while
		dup 1+ pick r@ = if
			dup 1+ roll drop
			-1 module-stack@ module-count +!
			swap 1- swap
		then
		1-
	repeat
	drop rdrop set-order
;

\ Old find hook
variable old-find-hook

\ Find the first path separator in a name
: find-path-sep ( caddr u -- u'|-1 )
	swap 1+ swap 1-
	1 begin over 2 > while
			2 pick c@ ':' = if
				2 pick 1+ c@ ':' = if
					nip nip exit
				then
			then
			rot 1+ rot 1- rot 1+
		repeat
	2drop drop -1
;

: ?drop			( ... 0 | <>0 -- ... | ... 0 )					\ Drop TOS but only if non zero
	0= if 0 then
;

\ Execute or compile a word in the provided module
: do-module-find ( caddr u -- xt -1|xt 1|0 )
	2dup find-path-sep dup -1 <>  if										( caddr u u' )
		2 pick																						( caddr u u' caddr )
		over																							( caddr u u' caddr u' )
		old-find-hook @ execute														( caddr u u' 0|nt 1|nt -1 )
		?dup if drop																			( caddr u u' xt )
			>r 2 + tuck																			( caddr u'' u u' )
			- -rot +																				( u-u' caddr' )
			swap r>																					( caddr' u-u' xt )
			-rot 2>r																				( xt r: caddr' u-u' )
			>r get-order r>
			execute
			1 set-order
			2r> find-word
			2>r set-order 2r>
		else
			2drop drop 0
		then
	else
		drop old-find-hook @ execute
	then
;

: constant-with-nt
	name>string
	constant-with-name
;


public-defs

\ Start a module definition
: begin-module ( "name" -- )
	parse-word dup 0<> averts x-tok-expected
	2dup find-word
	?dup if
		['] x-defined execute -20 throw
	else
		wordlist dup >r -rot constant-with-name r>
	then
	dup push-stack
	add
;

: continue-module ( "name" -- )
	parse-word dup 0<> averts x-tok-expected
	2dup find-word
	?dup if
		drop nip nip execute
	else
		['] x-undefined execute -20 throw
	then
	dup push-stack
	add
;

\ Start a private module definition
: private-module		( -- )
	wordlist dup push-stack add
;

: end-module				( -- )
	drop-stack
;

\ End a module def and place the module on the stack
: end-module>
	mod-stk-idx @ 1 > averts x-stk-underflow
	module-stack@ module @
	drop-stack
;

\ Import a module
: import	add ;

\ Unimport a module
: unimport remove ;

0 mod-stk-idx !

.( Installing module word find hook...)
forth-wordlist push-stack
forth-wordlist add

find-word-vec @ old-find-hook !
' do-module-find find-word-vec !
.( Done.) cr

run-tests @ [if]
.( Module testing... Should be four Hellos and a Hello again) cr
begin-module modtest1
	10 constant tenconst
	20 constant twentyconst
	: printhi ." Hello modular world!" cr ;
	printhi
end-module

modtest1::printhi

modtest1 import
printhi
modtest1 unimport

continue-module modtest1
	: printhi1 printhi ." Hello again from modular world!" cr ;
end-module

modtest1::printhi1

[defined] printhi [if] .( printhi defined) cr [else] .( printhi undefined) cr [then]
[then]

\ *** code / code; and friends
.( Code, end-code...) cr

: ;code
  postpone *fix-cfa
; IMMEDIATE

: (code) here latest >cfa ! ;
: code : (code) ;
: (end-code-int) latest toggle-hide [compile] [ ;
: (end-code) (end-code-int) ; IMMEDIATE
: end-code [compile] *emit-next (end-code-int) ; IMMEDIATE
hide-name (end-code-int)
hide-name (end-code)
hide-name (code)

\ ****

\ Print stats
get-ticks swap -
1000 /
swap here swap -
dup . .( / ) 8 / . .( bytes / cells used by startup code.) cr
.( Loaded in ) . .( ms.) cr
\ Hide internal words (is-compiling-rc 0 = remove internal from default search order)
0 is-compiling-rc !
-1 set-order
